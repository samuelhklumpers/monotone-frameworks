-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/mf#readme</a>
@package mf
@version 0.1.0.0

module Lexer

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
utf8Encode' :: Char -> (Word8, [Word8])
type Byte = Word8
type AlexInput = (Char, [Byte], String)
alexInputPrevChar :: AlexInput -> Char
alexScanTokens :: String -> [Token]
alexGetByte :: AlexInput -> Maybe (Byte, AlexInput)
alex_tab_size :: Int
alex_base :: AlexAddr
alex_table :: AlexAddr
alex_check :: AlexAddr
alex_deflt :: AlexAddr
alex_accept :: Array Int (AlexAcc user)
alex_actions :: Array Int (String -> Token)
data AlexAddr
AlexA# :: Addr# -> AlexAddr
alexIndexInt16OffAddr :: AlexAddr -> Int# -> Int#
alexIndexInt32OffAddr :: AlexAddr -> Int# -> Int#
quickIndex :: Array Int (AlexAcc (Any :: Type)) -> Int -> AlexAcc (Any :: Type)
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a
alexScan :: (Char, [Byte], String) -> Int -> AlexReturn (String -> Token)
alexScanUser :: t -> (Char, [Byte], String) -> Int -> AlexReturn (String -> Token)
alex_scan_tkn :: t1 -> t2 -> Int# -> AlexInput -> Int# -> AlexLastAcc -> (AlexLastAcc, (Char, [Byte], String))
data AlexLastAcc
AlexNone :: AlexLastAcc
AlexLastAcc :: !Int -> !AlexInput -> !Int -> AlexLastAcc
AlexLastSkip :: !AlexInput -> !Int -> AlexLastAcc
data AlexAcc user
AlexAccNone :: AlexAcc user
AlexAcc :: Int -> AlexAcc user
AlexAccSkip :: AlexAcc user
data Token
TIdent :: String -> Token
TInt :: Int -> Token
TBool :: Bool -> Token
TIf :: Token
TThen :: Token
TElse :: Token
TWhile :: Token
TDo :: Token
TPrint :: Token
TSkip :: Token
TNot :: Token
TIAssign :: Token
TBAssign :: Token
TArithmeticOp :: String -> Token
TStar :: Token
TBoolOp :: String -> Token
TRelOp :: String -> Token
TSemicolon :: Token
TBlockOpen :: Token
TBlockClose :: Token
TParenOpen :: Token
TParenClose :: Token
TBraceOpen :: Token
TBraceClose :: Token
TBegin :: Token
TEnd :: Token
TProc :: Token
TIs :: Token
TVal :: Token
TRes :: Token
TCall :: Token
TComma :: Token
TMalloc :: Token
TFree :: Token
TContinue :: Token
TBreak :: Token
TTyInt :: Token
alex :: String -> [Token]
alex_action_2 :: p -> Token
alex_action_3 :: p -> Token
alex_action_4 :: p -> Token
alex_action_5 :: p -> Token
alex_action_6 :: p -> Token
alex_action_7 :: p -> Token
alex_action_8 :: p -> Token
alex_action_9 :: p -> Token
alex_action_10 :: p -> Token
alex_action_11 :: p -> Token
alex_action_12 :: p -> Token
alex_action_13 :: p -> Token
alex_action_14 :: p -> Token
alex_action_15 :: p -> Token
alex_action_16 :: String -> Token
alex_action_17 :: p -> Token
alex_action_18 :: String -> Token
alex_action_19 :: String -> Token
alex_action_20 :: String -> Token
alex_action_21 :: String -> Token
alex_action_22 :: p -> Token
alex_action_23 :: p -> Token
alex_action_24 :: p -> Token
alex_action_25 :: p -> Token
alex_action_26 :: p -> Token
alex_action_27 :: p -> Token
alex_action_28 :: p -> Token
alex_action_29 :: p -> Token
alex_action_30 :: p -> Token
alex_action_31 :: p -> Token
alex_action_32 :: p -> Token
alex_action_33 :: p -> Token
alex_action_34 :: p -> Token
alex_action_35 :: p -> Token
alex_action_36 :: p -> Token
alex_action_37 :: p -> Token
alex_action_38 :: p -> Token
alex_action_39 :: p -> Token
alex_action_40 :: String -> Token
alex_action_41 :: String -> Token
instance GHC.Show.Show Lexer.Token
instance GHC.Classes.Eq Lexer.Token

module Std
(!=) :: Eq a => a -> a -> Bool
(.:) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
infixr 9 .:
compose :: [a -> a] -> a -> a
iterateFinite :: (a -> Either b a) -> a -> ([a], b)
foldr1 :: Foldable1 f => (a -> a -> a) -> f a -> a
intercalate :: (Monoid a, Foldable t) => a -> t a -> a
(<<*>>) :: (Applicative f, Applicative g) => f (g (a -> b)) -> f (g a) -> f (g b)
infixl 4 <<*>>
some :: Alternative f => f a -> f (NonEmpty a)
bind2 :: Monad m => (a -> b -> m c) -> m a -> m b -> m c
readFileUtf8 :: (MonadIO m, ConvertUtf8 text ByteString) => Path b File -> m text
sortNonEmptyOn :: Ord b => (a -> b) -> NonEmpty a -> NonEmpty a

-- | fails if the second argument is <a>minBound</a>
fromToUnsafe :: Enum a => a -> a -> [a]

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: forall (r :: RuntimeRep) a (b :: TYPE r). a -> b -> b
infixr 0 `seq`

-- | &lt;math&gt;. <a>filter</a>, applied to a predicate and a list,
--   returns the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | &lt;math&gt;. <a>map</a> <tt>f xs</tt> is the list obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
--   
--   This function is runtime-representation polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt>coerce @Int @Age 42</tt>.
coerce :: forall (k :: RuntimeRep) (a :: TYPE k) (b :: TYPE k). Coercible a b => a -> b

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>IsList</a> class and its methods are intended to be used in
--   conjunction with the OverloadedLists extension.
class IsList l

-- | The <a>fromList</a> function constructs the structure <tt>l</tt> from
--   the given list of <tt>Item l</tt>
fromList :: IsList l => [Item l] -> l

-- | The <a>fromListN</a> function takes the input list's length as a hint.
--   Its behaviour should be equivalent to <a>fromList</a>. The hint can be
--   used to construct the structure <tt>l</tt> more efficiently compared
--   to <a>fromList</a>. If the given hint does not equal to the input
--   list's length the behaviour of <a>fromListN</a> is not specified.
fromListN :: IsList l => Int -> [Item l] -> l

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | the successor of a value. For numeric types, <a>succ</a> adds 1.
succ :: Enum a => a -> a

-- | the predecessor of a value. For numeric types, <a>pred</a> subtracts
--   1.
pred :: Enum a => a -> a

-- | Convert from an <a>Int</a>.
toEnum :: Enum a => Int -> a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | Used in Haskell's translation of <tt>[n..]</tt> with <tt>[n..] =
--   enumFrom n</tt>, a possible implementation being <tt>enumFrom n = n :
--   enumFrom (succ n)</tt>. For example:
--   
--   <ul>
--   <li><pre>enumFrom 4 :: [Integer] = [4,5,6,7,...]</pre></li>
--   <li><pre>enumFrom 6 :: [Int] = [6,7,8,9,...,maxBound ::
--   Int]</pre></li>
--   </ul>
enumFrom :: Enum a => a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..]</tt> with <tt>[n,n'..] =
--   enumFromThen n n'</tt>, a possible implementation being
--   <tt>enumFromThen n n' = n : n' : worker (f x) (f x n')</tt>,
--   <tt>worker s v = v : worker s (s v)</tt>, <tt>x = fromEnum n' -
--   fromEnum n</tt> and <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt;
--   0 = f (n + 1) (pred y) | otherwise = y</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThen 4 6 :: [Integer] = [4,6,8,10...]</pre></li>
--   <li><pre>enumFromThen 6 2 :: [Int] = [6,2,-2,-6,...,minBound ::
--   Int]</pre></li>
--   </ul>
enumFromThen :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n..m]</tt> with <tt>[n..m] =
--   enumFromTo n m</tt>, a possible implementation being <tt>enumFromTo n
--   m | n &lt;= m = n : enumFromTo (succ n) m | otherwise = []</tt>. For
--   example:
--   
--   <ul>
--   <li><pre>enumFromTo 6 10 :: [Int] = [6,7,8,9,10]</pre></li>
--   <li><pre>enumFromTo 42 1 :: [Integer] = []</pre></li>
--   </ul>
enumFromTo :: Enum a => a -> a -> [a]

-- | Used in Haskell's translation of <tt>[n,n'..m]</tt> with <tt>[n,n'..m]
--   = enumFromThenTo n n' m</tt>, a possible implementation being
--   <tt>enumFromThenTo n n' m = worker (f x) (c x) n m</tt>, <tt>x =
--   fromEnum n' - fromEnum n</tt>, <tt>c x = bool (&gt;=) (<a>(x</a>
--   0)</tt> <tt>f n y | n &gt; 0 = f (n - 1) (succ y) | n &lt; 0 = f (n +
--   1) (pred y) | otherwise = y</tt> and <tt>worker s c v m | c v m = v :
--   worker s c (s v) m | otherwise = []</tt> For example:
--   
--   <ul>
--   <li><pre>enumFromThenTo 4 2 -6 :: [Integer] =
--   [4,2,0,-2,-4,-6]</pre></li>
--   <li><pre>enumFromThenTo 6 8 2 :: [Int] = []</pre></li>
--   </ul>
enumFromThenTo :: Enum a => a -> a -> a -> [a]

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)

-- | Using <tt>ApplicativeDo</tt>: '<tt><a>fmap</a> f as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do a &lt;- as
--      pure (f a)
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>a <a>&lt;$</a> bs</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do bs
--      pure a
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 +
infixl 7 *
infixl 6 -

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >
infix 4 <=
infix 4 <
infix 4 >=

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>fs <a>&lt;*&gt;</a> as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do f &lt;- fs
--      a &lt;- as
--      pure (f a)
--   </pre>
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
--   
--   This became a typeclass method in 4.10.0.0. Prior to that, it was a
--   function defined in terms of <a>&lt;*&gt;</a> and <a>fmap</a>.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>liftA2</a> f as bs</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do a &lt;- as
--      b &lt;- bs
--      pure (f a b)
--   </pre>
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
--   
--   '<tt>as <a>*&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
--   
--   This is a tad complicated for our <tt>ApplicativeDo</tt> extension
--   which will give it a <tt>Monad</tt> constraint. For an
--   <tt>Applicative</tt> constraint we write it of the form
--   
--   <pre>
--   do _ &lt;- as
--      b &lt;- bs
--      pure b
--   </pre>
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>as <a>&lt;*</a> bs</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do a &lt;- as
--      bs
--      pure a
--   </pre>
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*
infixl 4 *>
infixl 4 <*>

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | A variant of <a>foldMap</a> that is strict in the accumulator.
foldMap' :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>traverse</a> f = <a>traverse</a> (t .
--   f)</tt> for every applicative transformation <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>traverse</a> <a>Identity</a> =
--   <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>traverse</a> (<a>Compose</a> .
--   <a>fmap</a> g . f) = <a>Compose</a> . <a>fmap</a> (<a>traverse</a> g)
--   . <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>sequenceA</a> = <a>sequenceA</a> .
--   <a>fmap</a> t</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>sequenceA</a> . <a>fmap</a> <a>Identity</a>
--   = <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>sequenceA</a> . <a>fmap</a>
--   <a>Compose</a> = <a>Compose</a> . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   A result of the naturality law is a purity law for <a>traverse</a>
--   
--   <pre>
--   <a>traverse</a> <a>pure</a> = <a>pure</a>
--   </pre>
--   
--   (The naturality law is implied by parametricity and thus so is the
--   purity law [1, p15].)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
--   
--   References: [1] The Essence of the Iterator Pattern, Jeremy Gibbons
--   and Bruno C. d. S. Oliveira
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a

-- | This class gives the integer associated with a type-level natural.
--   There are instances of the class for every concrete literal: 0, 1, 2,
--   etc.
class KnownNat (n :: Nat)
class IsLabel (x :: Symbol) a
fromLabel :: IsLabel x a => a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&gt; [4,5,6]
--   [1,2,3,4,5,6]
--   </pre>
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <a>&lt;&gt;</a>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.List.NonEmpty
--   
--   &gt;&gt;&gt; sconcat $ "Hello" :| [" ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in &lt;math&gt; by picking
--   <tt>stimes = <a>stimesIdempotent</a></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
--   
--   <pre>
--   &gt;&gt;&gt; stimes 4 [1]
--   [1,1,1,1]
--   </pre>
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello world" &lt;&gt; mempty
--   "Hello world"
--   </pre>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>. Should it be implemented manually, since
--   <a>mappend</a> is a synonym for (<a>&lt;&gt;</a>), it is expected that
--   the two functions are defined the same way. In a future GHC release
--   <a>mappend</a> will be removed from <a>Monoid</a>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
--   
--   <pre>
--   &gt;&gt;&gt; mconcat ["Hello", " ", "Haskell", "!"]
--   "Hello Haskell!"
--   </pre>
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double
D# :: Double# -> Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float
F# :: Float# -> Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | 8-bit signed integer type
data Int8

-- | 16-bit signed integer type
data Int16

-- | 32-bit signed integer type
data Int32

-- | 64-bit signed integer type
data Int64

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   For more information about this type's representation, see the
--   comments in its implementation.
data Integer

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Rational numbers, with numerator and denominator of some
--   <a>Integral</a> type.
--   
--   Note that <a>Ratio</a>'s instances inherit the deficiencies from the
--   type parameter's. For example, <tt>Ratio Natural</tt>'s <a>Num</a>
--   instance has similar problems to <a>Natural</a>'s.
data Ratio a

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | 8-bit unsigned integer type
data Word8

-- | 16-bit unsigned integer type
data Word16

-- | 32-bit unsigned integer type
data Word32

-- | 64-bit unsigned integer type
data Word64

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The kind of types with lifted values. For example <tt>Int ::
--   Type</tt>.
type Type = Type

-- | The kind of constraints, like <tt>Show a</tt>
data Constraint

-- | (Kind) This is the kind of type-level natural numbers.
data Nat

-- | Comparison of type-level naturals, as a function.
type family CmpNat (a :: Nat) (b :: Nat) :: Ordering

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:2:1 in interactive:Ghci1
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | A compact representation of a <a>Word8</a> vector.
--   
--   It has a lower memory overhead than a <a>ByteString</a> and does not
--   contribute to heap fragmentation. It can be converted to or from a
--   <a>ByteString</a> (at the cost of copying the string data). It
--   supports very few other operations.
--   
--   It is suitable for use as an internal representation for code that
--   needs to keep many short strings in memory, but it <i>should not</i>
--   be used as an interchange type. That is, it should not generally be
--   used in public APIs. The <a>ByteString</a> type is usually more
--   suitable for use in interfaces; it is more flexible and it supports a
--   wide range of operations.
data ShortByteString

-- | Reverse order of bytes in <a>Word16</a>.
byteSwap16 :: Word16 -> Word16

-- | Reverse order of bytes in <a>Word32</a>.
byteSwap32 :: Word32 -> Word32

-- | Reverse order of bytes in <a>Word64</a>.
byteSwap64 :: Word64 -> Word64

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data MVar a

-- | A class of types that can be fully evaluated.
class NFData a

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return <tt>()</tt>.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   Note: <a>Generic1</a> can be auto-derived starting with GHC 7.4
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic, Generic1)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   instance NFData1 Foo
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1, NFData, NFData1)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   instance NFData Colour where rnf = rwhnf
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: NFData a => a -> ()

-- | A set of values <tt>a</tt>.
data Set a

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data Map k a

-- | Boolean "not"
not :: Bool -> Bool

-- | Boolean "or", lazy in the second argument
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "and", lazy in the second argument
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
--   
--   See <a>Data.List</a> for operations on lists.
type String = [Char]

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>void</a> as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do as
--      pure ()
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> [a] -> [a]

-- | &lt;math&gt;. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: (a -> b -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. <a>scanr1</a> is a variant of <a>scanr</a> that has no
--   starting value argument.
scanr1 :: (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See
--   <a>iterate'</a> for a strict variant of this function.
iterate :: (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: Int -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>. It is capable of list fusion, but it is restricted to
--   its first list argument and its resulting list.
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function. For example, <tt><a>zipWith</a> (+)</tt> is applied to two
--   lists to produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: [(a, b, c)] -> ([a], [b], [c])

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char
even :: Integral a => a -> Bool
odd :: Integral a => a -> Bool

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | equivalent to <a>readsPrec</a> with a precedence of 0.
reads :: Read a => ReadS a

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a

-- | &lt;math&gt;. The <a>isPrefixOf</a> function takes two lists and
--   returns <a>True</a> iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | &lt;math&gt;. The <a>intersperse</a> function takes an element and a
--   list and `intersperses' that element between the elements of the list.
--   For example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: a -> [a] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from lowest to highest, keeping duplicates in
--   the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortBy :: (a -> a -> Ordering) -> [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and ignore the results. For a version that doesn't
--   ignore the results see <a>traverse</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | Pretty print a <a>CallStack</a>.
prettyCallStack :: CallStack -> String

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Return the current <a>CallStack</a>.
--   
--   Does *not* include the call-site of <a>callStack</a>.
callStack :: HasCallStack => CallStack

-- | Perform some computation without adding new entries to the
--   <a>CallStack</a>.
withFrozenCallStack :: HasCallStack => (HasCallStack => a) -> a

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle
comparisonEquivalence :: Comparison a -> Equivalence a

-- | Check for equivalence with <a>==</a>.
--   
--   Note: The instances for <a>Double</a> and <a>Float</a> violate
--   reflexivity for <tt>NaN</tt>.
defaultEquivalence :: Eq a => Equivalence a

-- | Compare using <a>compare</a>.
defaultComparison :: Ord a => Comparison a

-- | This is an infix version of <a>contramap</a> with the arguments
--   flipped.
(>$$<) :: Contravariant f => f b -> (a -> b) -> f a
infixl 4 >$$<

-- | This is an infix alias for <a>contramap</a>.
(>$<) :: Contravariant f => (a -> b) -> f b -> f a
infixl 4 >$<

-- | This is <a>&gt;$</a> with its arguments flipped.
($<) :: Contravariant f => f b -> b -> f a
infixl 4 $<

-- | If <tt>f</tt> is both <a>Functor</a> and <a>Contravariant</a> then by
--   the time you factor in the laws of each of those classes, it can't
--   actually use its argument in any meaningful capacity.
--   
--   This method is surprisingly useful. Where both instances exist and are
--   lawful we have the following laws:
--   
--   <pre>
--   <a>fmap</a> f ≡ <a>phantom</a>
--   <a>contramap</a> f ≡ <a>phantom</a>
--   </pre>
phantom :: (Functor f, Contravariant f) => f a -> f b

-- | The class of contravariant functors.
--   
--   Whereas in Haskell, one can think of a <a>Functor</a> as containing or
--   producing values, a contravariant functor is a functor that can be
--   thought of as <i>consuming</i> values.
--   
--   As an example, consider the type of predicate functions <tt>a -&gt;
--   Bool</tt>. One such predicate might be <tt>negative x = x &lt; 0</tt>,
--   which classifies integers as to whether they are negative. However,
--   given this predicate, we can re-use it in other situations, providing
--   we have a way to map values <i>to</i> integers. For instance, we can
--   use the <tt>negative</tt> predicate on a person's bank balance to work
--   out if they are currently overdrawn:
--   
--   <pre>
--   newtype Predicate a = Predicate { getPredicate :: a -&gt; Bool }
--   
--   instance Contravariant Predicate where
--     contramap f (Predicate p) = Predicate (p . f)
--                                            |   `- First, map the input...
--                                            `----- then apply the predicate.
--   
--   overdrawn :: Predicate Person
--   overdrawn = contramap personBankBalance negative
--   </pre>
--   
--   Any instance should be subject to the following laws:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>contramap</a> <a>id</a> =
--   <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>contramap</a> (g . f) = <a>contramap</a>
--   f . <a>contramap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type of
--   <a>contramap</a> and the first law, so you need only check that the
--   former condition holds.
class Contravariant (f :: Type -> Type)
contramap :: Contravariant f => (a -> b) -> f b -> f a

-- | Replace all locations in the output with the same value. The default
--   definition is <tt><a>contramap</a> . <a>const</a></tt>, but this may
--   be overridden with a more efficient version.
(>$) :: Contravariant f => b -> f b -> f a
infixl 4 >$
newtype Predicate a
Predicate :: (a -> Bool) -> Predicate a
[getPredicate] :: Predicate a -> a -> Bool

-- | Defines a total ordering on a type as per <a>compare</a>.
--   
--   This condition is not checked by the types. You must ensure that the
--   supplied values are valid total orderings yourself.
newtype Comparison a
Comparison :: (a -> a -> Ordering) -> Comparison a
[getComparison] :: Comparison a -> a -> a -> Ordering

-- | This data type represents an equivalence relation.
--   
--   Equivalence relations are expected to satisfy three laws:
--   
--   <ul>
--   <li><i>Reflexivity</i> <tt><a>getEquivalence</a> f a a =
--   True</tt></li>
--   <li><i>Symmetry</i> <tt><a>getEquivalence</a> f a b =
--   <a>getEquivalence</a> f b a</tt></li>
--   <li><i>Transitivity</i> If <tt><a>getEquivalence</a> f a b</tt> and
--   <tt><a>getEquivalence</a> f b c</tt> are both <a>True</a> then so is
--   <tt><a>getEquivalence</a> f a c</tt>.</li>
--   </ul>
--   
--   The types alone do not enforce these laws, so you'll have to check
--   them yourself.
newtype Equivalence a
Equivalence :: (a -> a -> Bool) -> Equivalence a
[getEquivalence] :: Equivalence a -> a -> a -> Bool

-- | Dual function arrows.
newtype Op a b
Op :: (b -> a) -> Op a b
[getOp] :: Op a b -> b -> a

-- | Right-to-left composition of functors. The composition of applicative
--   functors is always applicative, but the composition of monads is not
--   always a monad.
newtype Compose (f :: k -> Type) (g :: k1 -> k) (a :: k1)
Compose :: f (g a) -> Compose (f :: k -> Type) (g :: k1 -> k) (a :: k1)
[getCompose] :: Compose (f :: k -> Type) (g :: k1 -> k) (a :: k1) -> f (g a)
infixr 9 `Compose`
infixr 9 `Compose`

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>vacuous</a> theVoid</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do void &lt;- theVoid
--      pure (absurd void)
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
vacuous :: Functor f => f Void -> f a

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | Uninhabited data type
data Void

-- | Repeat a value <tt>n</tt> times.
--   
--   <pre>
--   mtimesDefault n a = a &lt;&gt; a &lt;&gt; ... &lt;&gt; a  -- using &lt;&gt; (n-1) times
--   </pre>
--   
--   Implemented using <a>stimes</a> and <a>mempty</a>.
--   
--   This is a suitable definition for an <tt>mtimes</tt> member of
--   <a>Monoid</a>.
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a

-- | A generalization of <a>cycle</a> to an arbitrary <a>Semigroup</a>. May
--   fail to terminate for some values in some semigroups.
cycle1 :: Semigroup m => m -> m

-- | Provide a Semigroup for an arbitrary Monoid.
--   
--   <b>NOTE</b>: This is not needed anymore since <a>Semigroup</a> became
--   a superclass of <a>Monoid</a> in <i>base-4.11</i> and this newtype be
--   deprecated at some point in the future.
data WrappedMonoid m

-- | <a>Option</a> is effectively <a>Maybe</a> with a better instance of
--   <a>Monoid</a>, built off of an underlying <a>Semigroup</a> instead of
--   an underlying <a>Monoid</a>.
--   
--   Ideally, this type would not exist at all and we would just fix the
--   <a>Monoid</a> instance of <a>Maybe</a>.
--   
--   In GHC 8.4 and higher, the <a>Monoid</a> instance for <a>Maybe</a> has
--   been corrected to lift a <a>Semigroup</a> instance instead of a
--   <a>Monoid</a> instance. Consequently, this type is no longer useful.
--   It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.
newtype Option a
Option :: Maybe a -> Option a
[getOption] :: Option a -> Maybe a

-- | The <a>sortWith</a> function sorts a list of elements using the user
--   supplied function to project something out of each element
sortWith :: Ord b => (a -> b) -> [a] -> [a]

-- | A default definition of <a>bifoldMap</a> in terms of the
--   <a>Bitraversable</a> operations.
--   
--   <pre>
--   <a>bifoldMapDefault</a> f g ≡
--       <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
bifoldMapDefault :: (Bitraversable t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m

-- | A default definition of <a>bimap</a> in terms of the
--   <a>Bitraversable</a> operations.
--   
--   <pre>
--   <a>bimapDefault</a> f g ≡
--        <a>runIdentity</a> . <a>bitraverse</a> (<a>Identity</a> . f) (<a>Identity</a> . g)
--   </pre>
bimapDefault :: Bitraversable t => (a -> b) -> (c -> d) -> t a c -> t b d

-- | <a>bifor</a> is <a>bitraverse</a> with the structure as the first
--   argument. For a version that ignores the results, see <a>bifor_</a>.
bifor :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)

-- | Sequences all the actions in a structure, building a new structure
--   with the same shape using the results of the actions. For a version
--   that ignores the results, see <a>bisequence_</a>.
--   
--   <pre>
--   <a>bisequence</a> ≡ <a>bitraverse</a> <a>id</a> <a>id</a>
--   </pre>
bisequence :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)

-- | <a>Bitraversable</a> identifies bifunctorial data structures whose
--   elements can be traversed in order, performing <a>Applicative</a> or
--   <a>Monad</a> actions at each element, and collecting a result
--   structure with the same shape.
--   
--   As opposed to <a>Traversable</a> data structures, which have one
--   variety of element on which an action can be performed,
--   <a>Bitraversable</a> data structures have two such varieties of
--   elements.
--   
--   A definition of <a>bitraverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt><a>bitraverse</a> (t . f) (t . g) ≡ t .
--   <a>bitraverse</a> f g</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>bitraverse</a> <a>Identity</a>
--   <a>Identity</a> ≡ <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>Compose</a> . <a>fmap</a>
--   (<a>bitraverse</a> g1 g2) . <a>bitraverse</a> f1 f2 ≡
--   <a>bitraverse</a> (<a>Compose</a> . <a>fmap</a> g1 . f1)
--   (<a>Compose</a> . <a>fmap</a> g2 . f2)</tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (<a>Applicative</a> f, <a>Applicative</a> g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations:
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   Some simple examples are <a>Either</a> and <tt>(,)</tt>:
--   
--   <pre>
--   instance Bitraversable Either where
--     bitraverse f _ (Left x) = Left &lt;$&gt; f x
--     bitraverse _ g (Right y) = Right &lt;$&gt; g y
--   
--   instance Bitraversable (,) where
--     bitraverse f g (x, y) = (,) &lt;$&gt; f x &lt;*&gt; g y
--   </pre>
--   
--   <a>Bitraversable</a> relates to its superclasses in the following
--   ways:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>runIdentity</a> . <a>bitraverse</a> (<a>Identity</a> . f) (<a>Identity</a> . g)
--   <a>bifoldMap</a> f g = <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
--   
--   These are available as <a>bimapDefault</a> and <a>bifoldMapDefault</a>
--   respectively.
class (Bifunctor t, Bifoldable t) => Bitraversable (t :: Type -> Type -> Type)

-- | Evaluates the relevant functions at each element in the structure,
--   running the action, and builds a new structure with the same shape,
--   using the results produced from sequencing the actions.
--   
--   <pre>
--   <a>bitraverse</a> f g ≡ <a>bisequenceA</a> . <a>bimap</a> f g
--   </pre>
--   
--   For a version that ignores the results, see <a>bitraverse_</a>.
bitraverse :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)

-- | The <a>bifind</a> function takes a predicate and a structure and
--   returns the leftmost element of the structure matching the predicate,
--   or <a>Nothing</a> if there is no such element.
bifind :: Bifoldable t => (a -> Bool) -> t a a -> Maybe a

-- | Determines whether all elements of the structure satisfy their
--   appropriate predicate argument.
biall :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | Determines whether any element of the structure satisfies its
--   appropriate predicate argument.
biany :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | <a>bior</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
bior :: Bifoldable t => t Bool Bool -> Bool

-- | <a>biand</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
biand :: Bifoldable t => t Bool Bool -> Bool

-- | Does the element occur in the structure?
bielem :: (Bifoldable t, Eq a) => a -> t a a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>.
bilength :: Bifoldable t => t a b -> Int

-- | Test whether the structure is empty.
binull :: Bifoldable t => t a b -> Bool

-- | Collects the list of elements of a structure, from left to right.
biList :: Bifoldable t => t a a -> [a]

-- | The sum of a collection of actions, generalizing <a>biconcat</a>.
biasum :: (Bifoldable t, Alternative f) => t (f a) (f a) -> f a

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results, see
--   <a>bisequence</a>.
bisequence_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()

-- | As <a>bitraverse_</a>, but with the structure as the primary argument.
--   For a version that doesn't ignore the results, see <a>bifor</a>.
--   
--   <pre>
--   &gt;&gt;&gt; &gt; bifor_ ('a', "bc") print (print . reverse)
--   'a'
--   "cb"
--   </pre>
bifor_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()

-- | Map each element of a structure using one of two actions, evaluate
--   these actions from left to right, and ignore the results. For a
--   version that doesn't ignore the results, see <a>bitraverse</a>.
bitraverse_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

-- | Left associative monadic bifold over a structure.
bifoldlM :: (Bifoldable t, Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a

-- | As <a>bifoldl</a>, but strict in the result of the reduction functions
--   at each step.
--   
--   This ensures that each step of the bifold is forced to weak head
--   normal form before being applied, avoiding the collection of thunks
--   that would otherwise occur. This is often what you want to strictly
--   reduce a finite structure to a single, monolithic result (e.g.,
--   <a>bilength</a>).
bifoldl' :: Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a

-- | Right associative monadic bifold over a structure.
bifoldrM :: (Bifoldable t, Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c

-- | As <a>bifoldr</a>, but strict in the result of the reduction functions
--   at each step.
bifoldr' :: Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c

-- | <a>Bifoldable</a> identifies foldable structures with two different
--   varieties of elements (as opposed to <a>Foldable</a>, which has one
--   variety of element). Common examples are <a>Either</a> and
--   <tt>(,)</tt>:
--   
--   <pre>
--   instance Bifoldable Either where
--     bifoldMap f _ (Left  a) = f a
--     bifoldMap _ g (Right b) = g b
--   
--   instance Bifoldable (,) where
--     bifoldr f g z (a, b) = f a (g b z)
--   </pre>
--   
--   A minimal <a>Bifoldable</a> definition consists of either
--   <a>bifoldMap</a> or <a>bifoldr</a>. When defining more than this
--   minimal set, one should ensure that the following identities hold:
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   <a>bifoldr</a> f g z t ≡ <a>appEndo</a> (<a>bifoldMap</a> (Endo . f) (Endo . g) t) z
--   </pre>
--   
--   If the type is also a <a>Bifunctor</a> instance, it should satisfy:
--   
--   <pre>
--   <a>bifoldMap</a> f g ≡ <a>bifold</a> . <a>bimap</a> f g
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   <a>bifoldMap</a> f g . <a>bimap</a> h i ≡ <a>bifoldMap</a> (f . h) (g . i)
--   </pre>
class Bifoldable (p :: Type -> Type -> Type)

-- | Combines the elements of a structure using a monoid.
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   </pre>
bifold :: (Bifoldable p, Monoid m) => p m m -> m

-- | Combines the elements of a structure, given ways of mapping them to a
--   common monoid.
--   
--   <pre>
--   <a>bifoldMap</a> f g
--        ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   </pre>
bifoldMap :: (Bifoldable p, Monoid m) => (a -> m) -> (b -> m) -> p a b -> m

-- | Combines the elements of a structure in a right associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldr</a> f g z ≡ <a>foldr</a> (<a>either</a> f g) z . toEitherList
--   </pre>
bifoldr :: Bifoldable p => (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c

-- | Combines the elements of a structure in a left associative manner.
--   Given a hypothetical function <tt>toEitherList :: p a b -&gt; [Either
--   a b]</tt> yielding a list of all elements of a structure in order, the
--   following would hold:
--   
--   <pre>
--   <a>bifoldl</a> f g z
--        ≡ <a>foldl</a> (acc -&gt; <a>either</a> (f acc) (g acc)) z . toEitherList
--   </pre>
--   
--   Note that if you want an efficient left-fold, you probably want to use
--   <a>bifoldl'</a> instead of <a>bifoldl</a>. The reason is that the
--   latter does not force the "inner" results, resulting in a thunk chain
--   which then must be evaluated from the outside-in.
bifoldl :: Bifoldable p => (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: [a] -> Maybe (NonEmpty a)

-- | Get a string representation of the current execution stack state.
showStackTrace :: IO (Maybe String)

-- | Get a trace of the current execution stack state.
--   
--   Returns <tt>Nothing</tt> if stack trace support isn't available on
--   host machine.
getStackTrace :: IO (Maybe [Location])

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>replicateM</a> 5 as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do a1 &lt;- as
--      a2 &lt;- as
--      a3 &lt;- as
--      a4 &lt;- as
--      a5 &lt;- as
--      pure [a1,a2,a3,a4,a5]
--   </pre>
--   
--   Note the <tt>Applicative</tt> constraint.
replicateM :: Applicative m => Int -> m a -> m [a]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | Repeat an action indefinitely.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>forever</a> as</tt>' can be
--   understood as the pseudo-<tt>do</tt> expression
--   
--   <pre>
--   do as
--      as
--      ..
--   </pre>
--   
--   with <tt>as</tt> repeating.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
forever :: Applicative f => f a -> f b

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldr</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from right to left, and
--   returning a final value of this accumulator together with the new
--   structure.
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <a>foldl</a>; it applies a function to each element of
--   a structure, passing an accumulating parameter from left to right, and
--   returning a final value of this accumulator together with the new
--   structure.
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | Lists, but with an <a>Applicative</a> functor based on zipping.
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 &&&

-- | <tt><a>withFile</a> name mode act</tt> opens a file using
--   <a>openFile</a> and passes the resulting handle to the computation
--   <tt>act</tt>. The handle will be closed on exit from <a>withFile</a>,
--   whether by normal termination or by raising an exception. If closing
--   the handle raises an exception, then this exception will be raised by
--   <a>withFile</a> rather than any exception raised by <tt>act</tt>.
withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | Write the supplied value into a <a>TVar</a>.
writeTVar :: TVar a -> a -> STM ()

-- | Return the current value stored in a <a>TVar</a>.
readTVar :: TVar a -> STM a

-- | Create a new <a>TVar</a> holding a value supplied
newTVar :: a -> STM (TVar a)

-- | Exception handling within STM actions.
--   
--   <tt><a>catchSTM</a> m f</tt> catches any exception thrown by
--   <tt>m</tt> using <a>throwSTM</a>, using the function <tt>f</tt> to
--   handle the exception. If an exception is thrown, any changes made by
--   <tt>m</tt> are rolled back, but changes prior to <tt>m</tt> persist.
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a

-- | A variant of <a>throw</a> that can only be used within the <a>STM</a>
--   monad.
--   
--   Throwing an exception in <tt>STM</tt> aborts the transaction and
--   propagates the exception. If the exception is caught via
--   <a>catchSTM</a>, only the changes enclosed by the catch are rolled
--   back; changes made outside of <a>catchSTM</a> persist.
--   
--   If the exception is not caught inside of the <a>STM</a>, it is
--   re-thrown by <a>atomically</a>, and the entire <a>STM</a> is rolled
--   back.
--   
--   Although <a>throwSTM</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e    `seq` x  ===&gt; throw e
--   throwSTM e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwSTM</a> will only cause
--   an exception to be raised when it is used within the <a>STM</a> monad.
--   The <a>throwSTM</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>STM</a> monad because
--   it guarantees ordering with respect to other <a>STM</a> operations,
--   whereas <a>throw</a> does not.
throwSTM :: Exception e => e -> STM a

-- | A monad supporting atomic memory transactions.
data STM a

-- | Shared memory locations that support atomic memory transactions.
data TVar a

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A mutable variable in the <a>IO</a> monad
data IORef a

-- | Pretty print a <a>SrcLoc</a>.
prettySrcLoc :: SrcLoc -> String

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <a>Const</a> functor.
newtype Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Maybe monoid returning the leftmost non-Nothing value.
--   
--   <tt><a>First</a> a</tt> is isomorphic to <tt><a>Alt</a> <a>Maybe</a>
--   a</tt>, but precedes it historically.
--   
--   <pre>
--   &gt;&gt;&gt; getFirst (First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world"))
--   Just "hello"
--   </pre>
--   
--   Use of this type is discouraged. Note the following equivalence:
--   
--   <pre>
--   Data.Monoid.First x === Maybe (Data.Semigroup.First x)
--   </pre>
--   
--   In addition to being equivalent in the structural sense, the two also
--   have <a>Monoid</a> instances that behave the same. This type will be
--   marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are
--   advised to use the variant from <a>Data.Semigroup</a> and wrap it in
--   <a>Maybe</a>.
newtype First a
First :: Maybe a -> First a
[getFirst] :: First a -> Maybe a

-- | Maybe monoid returning the rightmost non-Nothing value.
--   
--   <tt><a>Last</a> a</tt> is isomorphic to <tt><a>Dual</a> (<a>First</a>
--   a)</tt>, and thus to <tt><a>Dual</a> (<a>Alt</a> <a>Maybe</a> a)</tt>
--   
--   <pre>
--   &gt;&gt;&gt; getLast (Last (Just "hello") &lt;&gt; Last Nothing &lt;&gt; Last (Just "world"))
--   Just "world"
--   </pre>
--   
--   Use of this type is discouraged. Note the following equivalence:
--   
--   <pre>
--   Data.Monoid.Last x === Maybe (Data.Semigroup.Last x)
--   </pre>
--   
--   In addition to being equivalent in the structural sense, the two also
--   have <a>Monoid</a> instances that behave the same. This type will be
--   marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are
--   advised to use the variant from <a>Data.Semigroup</a> and wrap it in
--   <a>Maybe</a>.
newtype Last a
Last :: Maybe a -> Last a
[getLast] :: Last a -> Maybe a

-- | This data type witnesses the lifting of a <a>Monoid</a> into an
--   <a>Applicative</a> pointwise.
newtype Ap (f :: k -> Type) (a :: k)
Ap :: f a -> Ap (f :: k -> Type) (a :: k)
[getAp] :: Ap (f :: k -> Type) (a :: k) -> f a

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in &lt;math&gt; rather than &lt;math&gt;.
stimesIdempotent :: Integral b => b -> a -> a

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getDual (mappend (Dual "Hello") (Dual "World"))
--   "WorldHello"
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Monoid under <a>&lt;|&gt;</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getAlt (Alt (Just 12) &lt;&gt; Alt (Just 24))
--   Just 12
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAlt $ Alt Nothing &lt;&gt; Alt (Just 24)
--   Just 24
--   </pre>
newtype Alt (f :: k -> Type) (a :: k)
Alt :: f a -> Alt (f :: k -> Type) (a :: k)
[getAlt] :: Alt (f :: k -> Type) (a :: k) -> f a

-- | Convert an integer into an unknown type-level natural.
someNatVal :: Natural -> SomeNat

natVal :: forall (n :: Nat) proxy. KnownNat n => proxy n -> Natural

-- | This type represents unknown type-level natural numbers.
data SomeNat
SomeNat :: Proxy n -> SomeNat

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy (comparing
--   f)</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | &lt;math&gt;. The <a>tails</a> function returns all final segments of
--   the argument, longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: [a] -> [[a]]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | &lt;math&gt;. The <a>genericLength</a> function is an overloaded
--   version of <a>length</a>. In particular, instead of returning an
--   <a>Int</a>, it returns any type which is an instance of <a>Num</a>. It
--   is, however, less efficient than <a>length</a>.
--   
--   <pre>
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Int
--   3
--   
--   &gt;&gt;&gt; genericLength [1, 2, 3] :: Float
--   3.0
--   </pre>
genericLength :: Num i => [a] -> i

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: [[a]] -> [[a]]

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: b -> Either a b -> b

-- | Return the contents of a <a>Left</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft 1 (Left 3)
--   3
--   
--   &gt;&gt;&gt; fromLeft 1 (Right "foo")
--   1
--   </pre>
fromLeft :: a -> Either a b -> a

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>). If <tt>a</tt> has
--   an <tt><a>Ord</a></tt> instance associated with it then comparing two
--   values thus wrapped will give you the opposite of their normal sort
--   order. This is particularly useful when sorting in generalised list
--   comprehensions, as in: <tt>then sortWith by <a>Down</a> x</tt>
newtype Down a
Down :: a -> Down a

[getDown] :: Down a -> a

-- | Left-to-right composition
(>>>) :: forall k cat (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | Right-to-left composition
(<<<) :: forall k cat (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
infixr 1 <<<

-- | See <a>openFile</a>
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | Attempt to convert an <a>Integral</a> type <tt>a</tt> to an
--   <a>Integral</a> type <tt>b</tt> using the size of the types as
--   measured by <a>Bits</a> methods.
--   
--   A simpler version of this function is:
--   
--   <pre>
--   toIntegral :: (Integral a, Integral b) =&gt; a -&gt; Maybe b
--   toIntegral x
--     | toInteger x == y = Just (fromInteger y)
--     | otherwise        = Nothing
--     where
--       y = toInteger x
--   </pre>
--   
--   This version requires going through <a>Integer</a>, which can be
--   inefficient. However, <tt>toIntegralSized</tt> is optimized to allow
--   GHC to statically determine the relative type sizes (as measured by
--   <a>bitSizeMaybe</a> and <a>isSigned</a>) and avoid going through
--   <a>Integer</a> for many types. (The implementation uses
--   <a>fromIntegral</a>, which is itself optimized with rules for
--   <tt>base</tt> types but may go through <a>Integer</a> for some type
--   pairs.)
toIntegralSized :: (Integral a, Integral b, Bits a, Bits b) => a -> Maybe b

-- | Bitwise "xor"
xor :: Bits a => a -> a -> a
infixl 6 `xor`

-- | Extract the denominator of the ratio in reduced form: the numerator
--   and denominator have no common factor and the denominator is positive.
denominator :: Ratio a -> a

-- | Extract the numerator of the ratio in reduced form: the numerator and
--   denominator have no common factor and the denominator is positive.
numerator :: Ratio a -> a
boundedEnumFromThen :: (Enum a, Bounded a) => a -> a -> [a]
boundedEnumFrom :: (Enum a, Bounded a) => a -> [a]

-- | &lt;math&gt;. A strictly accumulating version of <a>scanl</a>
scanl' :: (b -> a -> b) -> b -> [a] -> [b]

-- | &lt;math&gt;. Decompose a list into its head and tail. If the list is
--   empty, returns <a>Nothing</a>. If the list is non-empty, returns
--   <tt><a>Just</a> (x, xs)</tt>, where <tt>x</tt> is the head of the list
--   and <tt>xs</tt> its tail.
uncons :: [a] -> Maybe (a, [a])

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: a -> a -> Bool -> a

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a>’s argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a

-- | Flipped version of <a>&lt;$</a>.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>as <a>$&gt;</a> b</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do as
--      pure b
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | Swap the components of a pair.
swap :: (a, b) -> (b, a)

-- | Returns a <tt>[String]</tt> representing the current call stack. This
--   can be useful for debugging.
--   
--   The implementation uses the call-stack simulation maintained by the
--   profiler, so it only works if the program was compiled with
--   <tt>-prof</tt> and contains suitable SCC annotations (e.g. by using
--   <tt>-fprof-auto</tt>). Otherwise, the list returned is likely to be
--   empty or uninformative.
currentCallStack :: IO [String]
maxInt :: Int
minInt :: Int

-- | Lift a ternary function to actions.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>liftA3</a> f as bs cs</tt>' can
--   be understood as the <tt>do</tt> expression
--   
--   <pre>
--   do a &lt;- as
--      b &lt;- bs
--      c &lt;- cs
--      pure (f a b c)
--   </pre>
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>as <a>&lt;**&gt;</a> fs</tt>' can
--   be understood as the <tt>do</tt> expression
--   
--   <pre>
--   do a &lt;- as
--      f &lt;- fs
--      pure (f a)
--   </pre>
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | Extract a list of call-sites from the <a>CallStack</a>.
--   
--   The list is ordered by most recent call.
getCallStack :: CallStack -> [([Char], SrcLoc)]

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>mappend x x = x</tt>, this definition should be preferred,
--   because it works in &lt;math&gt; rather than &lt;math&gt;
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | <i>O(n)</i>. Convert a <a>ShortByteString</a> into a
--   <a>ByteString</a>.
fromShort :: ShortByteString -> ByteString

-- | <i>O(n)</i>. Convert a <a>ByteString</a> into a
--   <a>ShortByteString</a>.
--   
--   This makes a copy, so does not retain the input string.
toShort :: ByteString -> ShortByteString

-- | A map of integers to values <tt>a</tt>.
data IntMap a

-- | A set of integers.
data IntSet

-- | General-purpose finite sequences.
data Seq a

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | the deep analogue of <a>$!</a>. In the expression <tt>f $!! x</tt>,
--   <tt>x</tt> is fully evaluated before the function <tt>f</tt> is
--   applied to it.
($!!) :: NFData a => (a -> b) -> a -> b
infixr 0 $!!

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
deepseq :: NFData a => a -> b -> b

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or exit.
--   
--   The <a>return</a> function yields a computation that produces that
--   value, while <tt>&gt;&gt;=</tt> sequences two subcomputations, exiting
--   if either computation does.
newtype MaybeT (m :: Type -> Type) a
MaybeT :: m (Maybe a) -> MaybeT (m :: Type -> Type) a
[runMaybeT] :: MaybeT (m :: Type -> Type) a -> m (Maybe a)

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e (m :: Type -> Type) a

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | The trivial monad transformer, which maps a monad to an equivalent
--   monad.
data IdentityT (f :: k -> Type) (a :: k)

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: MonadState s m => (s -> s) -> m ()

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: Type -> Type) | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment.
reader :: MonadReader r m => (r -> a) -> m a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
newtype ReaderT r (m :: Type -> Type) a
ReaderT :: (r -> m a) -> ReaderT r (m :: Type -> Type) a
[runReaderT] :: ReaderT r (m :: Type -> Type) a -> r -> m a

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
type Reader r = ReaderT r Identity

-- | Runs a <tt>Reader</tt> and extracts the final value from it. (The
--   inverse of <a>reader</a>.)
runReader :: Reader r a -> r -> a

-- | Execute a computation in a modified environment (a specialization of
--   <a>withReaderT</a>).
--   
--   <ul>
--   <li><pre><a>runReader</a> (<a>withReader</a> f m) = <a>runReader</a> m
--   . f</pre></li>
--   </ul>
withReader :: (r' -> r) -> Reader r a -> Reader r' a

-- | Execute a computation in a modified environment (a more general
--   version of <a>local</a>).
--   
--   <ul>
--   <li><pre><a>runReaderT</a> (<a>withReaderT</a> f m) =
--   <a>runReaderT</a> m . f</pre></li>
--   </ul>
withReaderT :: forall r' r (m :: Type -> Type) a. (r' -> r) -> ReaderT r m a -> ReaderT r' m a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s (m :: Type -> Type) a
StateT :: (s -> m (a, s)) -> StateT s (m :: Type -> Type) a
[runStateT] :: StateT s (m :: Type -> Type) a -> s -> m (a, s)

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: State s a -> s -> (a, s)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: State s a -> s -> s

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: (s -> s) -> State s a -> State s a

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Strict version of <a>modifyTVar</a>.
modifyTVar' :: TVar a -> (a -> a) -> STM ()

-- | Make a <a>Weak</a> pointer to a <a>TMVar</a>, using the second
--   argument as a finalizer to run when the <a>TMVar</a> is
--   garbage-collected.
mkWeakTMVar :: TMVar a -> IO () -> IO (Weak (TMVar a))

-- | Check whether a given <a>TMVar</a> is empty.
isEmptyTMVar :: TMVar a -> STM Bool

-- | Swap the contents of a <a>TMVar</a> for a new value.
swapTMVar :: TMVar a -> a -> STM a

-- | A version of <a>readTMVar</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryReadTMVar :: TMVar a -> STM (Maybe a)

-- | This is a combination of <a>takeTMVar</a> and <a>putTMVar</a>; ie. it
--   takes the value from the <a>TMVar</a>, puts it back, and also returns
--   it.
readTMVar :: TMVar a -> STM a

-- | A version of <a>putTMVar</a> that does not <a>retry</a>. The
--   <a>tryPutTMVar</a> function attempts to put the value <tt>a</tt> into
--   the <a>TMVar</a>, returning <a>True</a> if it was successful, or
--   <a>False</a> otherwise.
tryPutTMVar :: TMVar a -> a -> STM Bool

-- | Put a value into a <a>TMVar</a>. If the <a>TMVar</a> is currently
--   full, <a>putTMVar</a> will <a>retry</a>.
putTMVar :: TMVar a -> a -> STM ()

-- | A version of <a>takeTMVar</a> that does not <a>retry</a>. The
--   <a>tryTakeTMVar</a> function returns <a>Nothing</a> if the
--   <a>TMVar</a> was empty, or <tt><a>Just</a> a</tt> if the <a>TMVar</a>
--   was full with contents <tt>a</tt>. After <a>tryTakeTMVar</a>, the
--   <a>TMVar</a> is left empty.
tryTakeTMVar :: TMVar a -> STM (Maybe a)

-- | Return the contents of the <a>TMVar</a>. If the <a>TMVar</a> is
--   currently empty, the transaction will <a>retry</a>. After a
--   <a>takeTMVar</a>, the <a>TMVar</a> is left empty.
takeTMVar :: TMVar a -> STM a

-- | Create a <a>TMVar</a> which is initially empty.
newEmptyTMVar :: STM (TMVar a)

-- | Create a <a>TMVar</a> which contains the supplied value.
newTMVar :: a -> STM (TMVar a)

-- | A <a>TMVar</a> is a synchronising variable, used for communication
--   between concurrent threads. It can be thought of as a box, which may
--   be empty or full.
data TMVar a

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   If the input contains any invalid UTF-8 data, the relevant exception
--   will be returned, otherwise the decoded text.
decodeUtf8' :: ByteString -> Either UnicodeException Text

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   <b>NOTE</b>: The replacement character returned by
--   <a>OnDecodeError</a> MUST be within the BMP plane; surrogate code
--   points will automatically be remapped to the replacement char
--   <tt>U+FFFD</tt> (<i>since 0.11.3.0</i>), whereas code points beyond
--   the BMP will throw an <a>error</a> (<i>since 1.2.3.1</i>); For earlier
--   versions of <tt>text</tt> using those unsupported code points would
--   result in undefined behavior.
decodeUtf8With :: OnDecodeError -> ByteString -> Text

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | Replace an invalid input byte with the Unicode replacement character
--   U+FFFD.
lenientDecode :: OnDecodeError

-- | Throw a <a>UnicodeException</a> if decoding fails.
strictDecode :: OnDecodeError

-- | Function type for handling a coding error. It is supplied with two
--   inputs:
--   
--   <ul>
--   <li>A <a>String</a> that describes the error.</li>
--   <li>The input value that caused the error. If the error arose because
--   the end of input was reached or could not be identified precisely,
--   this value will be <a>Nothing</a>.</li>
--   </ul>
--   
--   If the handler returns a value wrapped with <a>Just</a>, that value
--   will be used in the output as the replacement for the invalid input.
--   If it returns <a>Nothing</a>, no value will be used in the output.
--   
--   Should the handler need to abort processing, it should use
--   <a>error</a> or <a>throw</a> an exception (preferably a
--   <a>UnicodeException</a>). It may use the description provided to
--   construct a more helpful error report.
type OnError a b = String -> Maybe a -> Maybe b

-- | A handler for a decoding error.
type OnDecodeError = OnError Word8 Char

-- | An exception type for representing Unicode encoding errors.
data UnicodeException

-- | Convert a <a>ExceptT</a> computation to <a>MaybeT</a>, discarding the
--   value of any exception.
exceptToMaybeT :: forall (m :: Type -> Type) e a. Functor m => ExceptT e m a -> MaybeT m a

-- | Convert a <a>MaybeT</a> computation to <a>ExceptT</a>, with a default
--   exception value.
maybeToExceptT :: forall (m :: Type -> Type) e a. Functor m => e -> MaybeT m a -> ExceptT e m a
appliedTo :: Applicative f => f a -> f (a -> b) -> f b
pass :: Applicative f => f ()
(&&^) :: Monad m => m Bool -> m Bool -> m Bool
guardM :: MonadPlus m => m Bool -> m ()
guarded :: Alternative f => (a -> Bool) -> a -> f a
ifM :: Monad m => m Bool -> m a -> m a -> m a
unlessM :: Monad m => m Bool -> m () -> m ()
whenM :: Monad m => m Bool -> m () -> m ()
(||^) :: Monad m => m Bool -> m Bool -> m Bool
error :: forall (r :: RuntimeRep) (a :: TYPE r) t. (HasCallStack, IsText t) => t -> a
trace :: String -> a -> a
traceId :: String -> String
traceM :: Applicative f => String -> f ()
traceShow :: Show a => a -> b -> b
traceShowId :: Show a => a -> a
traceShowM :: (Show a, Applicative f) => a -> f ()
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a
evaluateNF :: (NFData a, MonadIO m) => a -> m a
evaluateNF_ :: (NFData a, MonadIO m) => a -> m ()
evaluateWHNF :: MonadIO m => a -> m a
evaluateWHNF_ :: MonadIO m => a -> m ()
pattern Exc :: Exception e => e -> SomeException
bug :: (HasCallStack, Exception e) => e -> a
appendFileBS :: MonadIO m => FilePath -> ByteString -> m ()
appendFileLBS :: MonadIO m => FilePath -> LByteString -> m ()
appendFileLText :: MonadIO m => FilePath -> LText -> m ()
appendFileText :: MonadIO m => FilePath -> Text -> m ()
readFileBS :: MonadIO m => FilePath -> m ByteString
readFileLBS :: MonadIO m => FilePath -> m LByteString
readFileLText :: MonadIO m => FilePath -> m LText
readFileText :: MonadIO m => FilePath -> m Text
writeFileBS :: MonadIO m => FilePath -> ByteString -> m ()
writeFileLBS :: MonadIO m => FilePath -> LByteString -> m ()
writeFileLText :: MonadIO m => FilePath -> LText -> m ()
writeFileText :: MonadIO m => FilePath -> Text -> m ()
allM :: (Foldable f, Monad m) => (a -> m Bool) -> f a -> m Bool
andM :: (Foldable f, Monad m) => f (m Bool) -> m Bool
anyM :: (Foldable f, Monad m) => (a -> m Bool) -> f a -> m Bool
asumMap :: forall b m f a. (Foldable f, Alternative m) => (a -> m b) -> f a -> m b
elem :: (Foldable f, DisallowElem f, Eq a) => a -> f a -> Bool
flipfoldl' :: Foldable f => (a -> b -> b) -> b -> f a -> b
foldMapA :: (Semigroup b, Monoid b, Applicative m, Foldable f) => (a -> m b) -> f a -> m b
foldMapM :: (Monoid b, Monad m, Foldable f) => (a -> m b) -> f a -> m b
notElem :: (Foldable f, DisallowElem f, Eq a) => a -> f a -> Bool
orM :: (Foldable f, Monad m) => f (m Bool) -> m Bool
product :: forall a f. (Foldable f, Num a) => f a -> a
sum :: forall a f. (Foldable f, Num a) => f a -> a
identity :: a -> a
(<<$>>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
(??) :: Functor f => f (a -> b) -> a -> f b
flap :: Functor f => f (a -> b) -> a -> f b
atomically :: MonadIO m => STM a -> m a
newEmptyMVar :: MonadIO m => m (MVar a)
newEmptyTMVarIO :: MonadIO m => m (TMVar a)
newMVar :: MonadIO m => a -> m (MVar a)
newTMVarIO :: MonadIO m => a -> m (TMVar a)
newTVarIO :: MonadIO m => a -> m (TVar a)
putMVar :: MonadIO m => MVar a -> a -> m ()
readMVar :: MonadIO m => MVar a -> m a
readTVarIO :: MonadIO m => TVar a -> m a
swapMVar :: MonadIO m => MVar a -> a -> m a
takeMVar :: MonadIO m => MVar a -> m a
tryPutMVar :: MonadIO m => MVar a -> a -> m Bool
tryReadMVar :: MonadIO m => MVar a -> m (Maybe a)
tryTakeMVar :: MonadIO m => MVar a -> m (Maybe a)
die :: MonadIO m => String -> m a
exitFailure :: MonadIO m => m a
exitSuccess :: MonadIO m => m a
exitWith :: MonadIO m => ExitCode -> m a
appendFile :: MonadIO m => FilePath -> String -> m ()
readFile :: MonadIO m => FilePath -> m String
writeFile :: MonadIO m => FilePath -> String -> m ()
atomicModifyIORef :: MonadIO m => IORef a -> (a -> (a, b)) -> m b
atomicModifyIORef' :: MonadIO m => IORef a -> (a -> (a, b)) -> m b
atomicModifyIORef'_ :: MonadIO m => IORef a -> (a -> a) -> m ()
atomicModifyIORef_ :: MonadIO m => IORef a -> (a -> a) -> m ()
atomicWriteIORef :: MonadIO m => IORef a -> a -> m ()
modifyIORef :: MonadIO m => IORef a -> (a -> a) -> m ()
modifyIORef' :: MonadIO m => IORef a -> (a -> a) -> m ()
newIORef :: MonadIO m => a -> m (IORef a)
readIORef :: MonadIO m => IORef a -> m a
writeIORef :: MonadIO m => IORef a -> a -> m ()
getLine :: MonadIO m => m Text
print :: forall a m. (MonadIO m, Show a) => a -> m ()
putStr :: MonadIO m => String -> m ()
putStrLn :: MonadIO m => String -> m ()
(!!?) :: [a] -> Int -> Maybe a
head :: IsNonEmpty f a a "head" => f a -> a
init :: IsNonEmpty f a [a] "init" => f a -> [a]
last :: IsNonEmpty f a a "last" => f a -> a
tail :: IsNonEmpty f a [a] "tail" => f a -> [a]
viaNonEmpty :: (NonEmpty a -> b) -> [a] -> Maybe b
whenNotNull :: Applicative f => [a] -> (NonEmpty a -> f ()) -> f ()
whenNotNullM :: Monad m => m [a] -> (NonEmpty a -> m ()) -> m ()
cycle :: [a] -> [a]
chainedTo :: Monad m => (a -> m b) -> m a -> m b
leftToMaybe :: Either l r -> Maybe l
maybeToLeft :: r -> Maybe l -> Either l r
maybeToRight :: l -> Maybe r -> Either l r
rightToMaybe :: Either l r -> Maybe r
whenLeft :: Applicative f => a -> Either l r -> (l -> f a) -> f a
whenLeftM :: Monad m => a -> m (Either l r) -> (l -> m a) -> m a
whenLeftM_ :: Monad m => m (Either l r) -> (l -> m ()) -> m ()
whenLeft_ :: Applicative f => Either l r -> (l -> f ()) -> f ()
whenRight :: Applicative f => a -> Either l r -> (r -> f a) -> f a
whenRightM :: Monad m => a -> m (Either l r) -> (r -> m a) -> m a
whenRightM_ :: Monad m => m (Either l r) -> (r -> m ()) -> m ()
whenRight_ :: Applicative f => Either l r -> (r -> f ()) -> f ()
(?:) :: Maybe a -> a -> a
mapMaybeM :: Monad m => (a -> m (Maybe b)) -> [a] -> m [b]
whenJust :: Applicative f => Maybe a -> (a -> f ()) -> f ()
whenJustM :: Monad m => m (Maybe a) -> (a -> m ()) -> m ()
whenNothing :: Applicative f => Maybe a -> f a -> f a
whenNothingM :: Monad m => m (Maybe a) -> m a -> m a
whenNothingM_ :: Monad m => m (Maybe a) -> m () -> m ()
whenNothing_ :: Applicative f => Maybe a -> f () -> f ()
etaReaderT :: forall r (m :: Type -> Type) a. ReaderT r m a -> ReaderT r m a
evaluatingState :: s -> State s a -> a
evaluatingStateT :: Functor f => s -> StateT s f a -> f a
executingState :: s -> State s a -> s
executingStateT :: Functor f => s -> StateT s f a -> f s
hoistEither :: forall (m :: Type -> Type) e a. Applicative m => Either e a -> ExceptT e m a
hoistMaybe :: forall (m :: Type -> Type) a. Applicative m => Maybe a -> MaybeT m a
usingReader :: r -> Reader r a -> a
usingReaderT :: r -> ReaderT r m a -> m a
usingState :: s -> State s a -> (a, s)
usingStateT :: s -> StateT s m a -> m (a, s)
maybeToMonoid :: Monoid m => Maybe m -> m
memptyIfFalse :: Monoid m => Bool -> m -> m
memptyIfTrue :: Monoid m => Bool -> m -> m
hashNub :: (Eq a, Hashable a) => [a] -> [a]
ordNub :: Ord a => [a] -> [a]
sortNub :: Ord a => [a] -> [a]
unstableNub :: (Eq a, Hashable a) => [a] -> [a]
integerToBounded :: (Integral a, Bounded a) => Integer -> Maybe a
integerToNatural :: Integer -> Maybe Natural
putBS :: MonadIO m => ByteString -> m ()
putBSLn :: MonadIO m => ByteString -> m ()
putLBS :: MonadIO m => LByteString -> m ()
putLBSLn :: MonadIO m => LByteString -> m ()
putLText :: MonadIO m => LText -> m ()
putLTextLn :: MonadIO m => LText -> m ()
putText :: MonadIO m => Text -> m ()
putTextLn :: MonadIO m => Text -> m ()
fromLazy :: LazyStrict l s => l -> s
fromStrict :: LazyStrict l s => s -> l
readEither :: Read a => String -> Either Text a
show :: forall b a. (Show a, IsString b) => a -> b
lines :: IsText t "lines" => t -> [t]
unlines :: IsText t "unlines" => [t] -> t
unwords :: IsText t "unwords" => [t] -> t
words :: IsText t "words" => t -> [t]
class Hashable a
hashWithSalt :: Hashable a => Int -> a -> Int
class One x where {
    type family OneItem x;
}
one :: One x => OneItem x -> x
type family OneItem x
data Undefined
Undefined :: Undefined
data Bug
Bug :: SomeException -> CallStack -> Bug
class ConvertUtf8 a b
encodeUtf8 :: ConvertUtf8 a b => a -> b
decodeUtf8 :: ConvertUtf8 a b => b -> a
decodeUtf8Strict :: ConvertUtf8 a b => b -> Either UnicodeException a
type LByteString = ByteString
type LText = Text
class LazyStrict l s | l -> s, s -> l
toLazy :: LazyStrict l s => s -> l
toStrict :: LazyStrict l s => l -> s
class ToLText a
toLText :: ToLText a => a -> LText
class ToString a
toString :: ToString a => a -> String
class ToText a
toText :: ToText a => a -> Text
data HashMap k v
data HashSet a

module MonotoneFrameworks
class (Monoid m, Eq m) => BoundedSemiLattice m
lessOrEquals :: BoundedSemiLattice m => m -> m -> Bool
bottom :: BoundedSemiLattice m => m
type Label = Int
data MonotoneFramework propertySpace
MonotoneFramework :: Map Label (Set Label) -> Set Label -> propertySpace -> Map Label (propertySpace -> propertySpace) -> InterproceduralFragment propertySpace -> MonotoneFramework propertySpace

-- | map of labels to the set of destination labels of all outgoing flow
--   from the first label
[flow] :: MonotoneFramework propertySpace -> Map Label (Set Label)
[extremalLabels] :: MonotoneFramework propertySpace -> Set Label
[extremalValue] :: MonotoneFramework propertySpace -> propertySpace
[transferFunctions] :: MonotoneFramework propertySpace -> Map Label (propertySpace -> propertySpace)
[interproceduralFragment] :: MonotoneFramework propertySpace -> InterproceduralFragment propertySpace

-- | invariant. call label is functionally dependent on the return label
newtype InterproceduralFragment propertySpace
InterproceduralFragment :: Map Label (Label, propertySpace -> propertySpace -> propertySpace) -> InterproceduralFragment propertySpace

-- | interprocedural MFP solution
--   
--   warning. partial. <a>transferFunctions</a> must cover all labels
--   except for call return labels.
--   
--   warning. termination is only guaranteed if <tt>propertySpace</tt>
--   satisfies the <i>Ascending Chain Condition</i>.
mfpSolution :: forall propertySpace. BoundedSemiLattice propertySpace => MonotoneFramework propertySpace -> (Map Label propertySpace, Map Label propertySpace, [(Map Label propertySpace, [(Label, Label)])])
mapFunctionWithCallLabel :: forall p0 p1. (Label -> (p0 -> p0 -> p0) -> p1 -> p1 -> p1) -> InterproceduralFragment p0 -> InterproceduralFragment p1
lookupCall :: forall propertySpace. Label -> InterproceduralFragment propertySpace -> Maybe (Label, propertySpace -> propertySpace -> propertySpace)
lookupReturn :: Label -> InterproceduralFragment propertySpace -> Maybe (Label, propertySpace -> propertySpace -> propertySpace)

module ContextSensitive
newtype ContextSensitive propertySpace
ContextSensitive :: Map [Label] propertySpace -> ContextSensitive propertySpace
[runTotalMap] :: ContextSensitive propertySpace -> Map [Label] propertySpace

-- | make a monotone framework instance context sensitive
contextSensitize :: forall propertySpace. BoundedSemiLattice propertySpace => Int -> MonotoneFramework propertySpace -> MonotoneFramework (ContextSensitive propertySpace)
mapWithContext :: forall propertySpace0 propertySpace1. ([Label] -> propertySpace0 -> propertySpace1) -> ContextSensitive propertySpace0 -> ContextSensitive propertySpace1
lookupContext :: forall propertySpace. BoundedSemiLattice propertySpace => [Label] -> ContextSensitive propertySpace -> Maybe propertySpace
mapContexts :: forall propertySpace. BoundedSemiLattice propertySpace => ([Label] -> [Label]) -> ContextSensitive propertySpace -> ContextSensitive propertySpace
instance GHC.Base.Functor ContextSensitive.ContextSensitive
instance GHC.Classes.Eq propertySpace => GHC.Classes.Eq (ContextSensitive.ContextSensitive propertySpace)
instance GHC.Show.Show propertySpace => GHC.Show.Show (ContextSensitive.ContextSensitive propertySpace)
instance GHC.Base.Semigroup propertySpace => GHC.Base.Semigroup (ContextSensitive.ContextSensitive propertySpace)
instance GHC.Base.Semigroup propertySpace => GHC.Base.Monoid (ContextSensitive.ContextSensitive propertySpace)
instance MonotoneFrameworks.BoundedSemiLattice propertySpace => MonotoneFrameworks.BoundedSemiLattice (ContextSensitive.ContextSensitive propertySpace)

module ConstantProp

-- | <pre>
--   Either Int Bool
--   </pre>
data ConstLat
CI :: Int -> ConstLat
CB :: Bool -> ConstLat

-- | Newtype for maps with the semigroup of intersection (as opposed to
--   left-biased union)
newtype ConstEnv
ConstEnv :: Map String ConstLat -> ConstEnv

-- | Lattice for the constant propagation analysis
type PtConstLat = Maybe ConstEnv
constEmpty :: ConstEnv

-- | Set this variable to a (non)-constant
setConst :: String -> Maybe ConstLat -> ConstEnv -> ConstEnv

-- | Mark this variable as non-constant
setNonConst :: String -> ConstEnv -> ConstEnv

-- | Lookup this variable in a <tt>ConstEnv</tt>
getConst :: String -> ConstEnv -> Maybe ConstLat

-- | Set this variable to the value of the given expression, as a function
--   from environment to value, evaluated in the given context
updateConst :: String -> (ConstEnv -> Maybe ConstLat) -> ConstEnv -> ConstEnv

-- | Transfer function for call: each parameter is initialized to the
--   lattice value of its input expression
callConst :: [String] -> String -> [ConstEnv -> Maybe ConstLat] -> ConstEnv -> ConstEnv

-- | Transfer function for return: restore all values of the parameters and
--   the return parameter, and copy the value from the return parameter to
--   the context before the call.
retConst :: String -> [String] -> String -> ConstEnv -> ConstEnv -> ConstEnv
cIII :: (Int -> Int -> Int) -> Maybe ConstLat -> Maybe ConstLat -> Maybe ConstLat
constMul :: Maybe ConstLat -> Maybe ConstLat -> Maybe ConstLat
cIIB :: (Int -> Int -> Bool) -> Maybe ConstLat -> Maybe ConstLat -> Maybe ConstLat
cBBB :: (Bool -> Bool -> Bool) -> Maybe ConstLat -> Maybe ConstLat -> Maybe ConstLat
constAnd :: Maybe ConstLat -> Maybe ConstLat -> Maybe ConstLat
constOr :: Maybe ConstLat -> Maybe ConstLat -> Maybe ConstLat
cBB :: (Bool -> Bool) -> Maybe ConstLat -> Maybe ConstLat
instance GHC.Classes.Eq ConstantProp.ConstLat
instance GHC.Show.Show ConstantProp.ConstLat
instance GHC.Classes.Eq ConstantProp.ConstEnv
instance MonotoneFrameworks.BoundedSemiLattice ConstantProp.PtConstLat
instance GHC.Show.Show ConstantProp.ConstEnv
instance GHC.Base.Semigroup ConstantProp.ConstEnv

module ConstantBranch

-- | Newtype for sets with the intersection semigroup (as opposed to
--   union).
newtype Intersect a
Intersect :: Set a -> Intersect a

-- | Lattice for branch aware constant propagation
type ConstBranchLat = (PtConstLat, Maybe (Intersect Int))

-- | Element relation for sets with an universal set adjoined: everything
--   is in the universe (<tt>Nothing</tt>)
element :: Ord a => a -> Maybe (Intersect a) -> Bool

-- | Ignore the unary transfer function at this label if it is dead
ignoreDead :: Int -> (PtConstLat -> PtConstLat) -> ConstBranchLat -> ConstBranchLat

-- | Ignore the binary transfer function at this label if it is dead
ignoreDead2 :: Int -> (PtConstLat -> PtConstLat -> PtConstLat) -> ConstBranchLat -> ConstBranchLat -> ConstBranchLat

-- | Discard the analysis value at this label if it is dead
constBranchId :: Int -> ConstBranchLat -> ConstBranchLat

-- | Transfer function for <tt>if</tt>: if the condition is always
--   <tt>true</tt>, the <tt>else</tt> branch is unreachable (dead) and the
--   <tt>then</tt> branch is made reachable, and vice versa when the
--   condition is always <tt>false</tt>. Otherwise, both are reachable.
constBranchIf :: (ConstEnv -> Maybe ConstLat) -> Int -> Int -> ConstBranchLat -> ConstBranchLat

-- | Transfer function for <tt>while</tt>: if the condition is always
--   <tt>false</tt>, the body is dead, and the label after the loop is made
--   reachable, if it is always <tt>true</tt>, then the program loops, and
--   the body is made reachable, and the label after is dead. Otherwise,
--   both are reachable.
constBranchWhile :: Maybe Int -> (ConstEnv -> Maybe ConstLat) -> Int -> Int -> ConstBranchLat -> ConstBranchLat

-- | Apply a binary function with optional first argument, if
--   <tt>Nothing</tt>, do nothing.
doIf :: (a -> b -> b) -> Maybe a -> b -> b
instance GHC.Show.Show a => GHC.Show.Show (ConstantBranch.Intersect a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (ConstantBranch.Intersect a)
instance MonotoneFrameworks.BoundedSemiLattice ConstantBranch.ConstBranchLat
instance GHC.Classes.Ord a => GHC.Base.Semigroup (ConstantBranch.Intersect a)

module Analyses

-- | Transfer functions per label, grouped by unary and binary
type DifTrans m = (Map Int (m -> m), Map Int (m -> m -> m))

-- | Insert a unary transfer function at the label
insertL :: Int -> (m -> m) -> DifTrans m -> DifTrans m

-- | Insert a binary transfer function at the label
insertR :: Int -> (m -> m -> m) -> DifTrans m -> DifTrans m

-- | Create a singleton <a>Map</a> with this unary transfer function at the
--   label
singleL :: Int -> (m -> m) -> DifTrans m

-- | Create a singleton <a>Map</a> with this binary transfer function at
--   the label
singleR :: Int -> (m -> m -> m) -> DifTrans m

-- | Lookup a unary transfer function
lookupL :: Int -> DifTrans p -> p -> p

-- | Lookup a binary transfer function
lookupR :: Int -> DifTrans p -> p -> p -> p

-- | Internal representation of "Proc'" as a record, for convenience
data Proc''
Proc'' :: Int -> Int -> String -> [String] -> String -> Proc''
[procEntry] :: Proc'' -> Int
[procExit] :: Proc'' -> Int
[procName] :: Proc'' -> String
[procInp] :: Proc'' -> [String]
[procOut] :: Proc'' -> String

-- | Type of procedure lookup tables
type DStar = [(String, Proc'')]
type Edge = (Int, Int)
data Inter
Inter :: Int -> Int -> Int -> Int -> Inter

-- | Unsafely lookup a procedure by its name
findProc :: String -> DStar -> Proc''

-- | Group by a key function
groupBy :: Ord k => (a -> k) -> [a] -> Map k [a]

-- | Group by the keys of a key/value function
groupBy' :: Ord k => (a -> (k, b)) -> [a] -> Map k [b]
concatSnd :: [(k, [(m, v)])] -> [(k, (m, v))]

-- | Flip the inner and outer keys of a nested map
flipMap :: (Ord k, Ord m) => Map k (Map m v) -> Map m (Map k v)
instance GHC.Classes.Ord Analyses.Proc''
instance GHC.Classes.Eq Analyses.Proc''
instance GHC.Show.Show Analyses.Proc''
instance GHC.Classes.Ord Analyses.Inter
instance GHC.Classes.Eq Analyses.Inter
instance GHC.Show.Show Analyses.Inter

module StrongLive

-- | If <tt>name</tt> is live in <tt>src</tt>, then the set
--   <tt>freeVars</tt> is live in <tt>dst</tt>
moveAlive :: Set String -> String -> Set String -> Set String -> Set String

-- | If <tt>name</tt> is live, then the set <tt>freeVars</tt> is live
keepAlive :: String -> Set String -> Set String -> Set String

-- | Transfer function for call: everything that lives in the procedure
--   remains live, except for the parameters, everything that lives after
--   the return remains live, except for the return parameter, and for each
--   parameter that is live in the procedure, all the free variables of its
--   input value are live.
aliveInCall :: [String] -> String -> [Set String] -> Set String -> Set String -> Set String

-- | Transfer function for return: everything that lives after the return
--   remains live, except for the output variable and input parameters, if
--   the output variable was live then the output parameter also becomes
--   live
aliveInExit :: [String] -> String -> String -> Set String -> Set String
applyIf :: (a -> a) -> Bool -> a -> a
instance MonotoneFrameworks.BoundedSemiLattice (Data.Set.Internal.Set GHC.Base.String)

module AttributeGrammar
indent :: [String] -> [String]
showLabel :: Int -> String
addSemicolon :: [String] -> [String]
parensIf :: Bool -> String -> String
data BExpr
BConst :: Bool -> BExpr
BVar :: String -> BExpr
LessThan :: IExpr -> IExpr -> BExpr
GreaterThan :: IExpr -> IExpr -> BExpr
LessEqual :: IExpr -> IExpr -> BExpr
GreaterEqual :: IExpr -> IExpr -> BExpr
IEqual :: IExpr -> IExpr -> BExpr
BEqual :: BExpr -> BExpr -> BExpr
And :: BExpr -> BExpr -> BExpr
Or :: BExpr -> BExpr -> BExpr
Not :: BExpr -> BExpr
sem_BExpr :: BExpr -> T_BExpr
type T_BExpr = ((ConstEnv -> Maybe ConstLat), (Set String), Int, String, BExpr)
data Inh_BExpr
Inh_BExpr :: Inh_BExpr
data Syn_BExpr
Syn_BExpr :: (ConstEnv -> Maybe ConstLat) -> Set String -> Int -> String -> BExpr -> Syn_BExpr
[constantPropagation_Syn_BExpr] :: Syn_BExpr -> ConstEnv -> Maybe ConstLat
[freeVars_Syn_BExpr] :: Syn_BExpr -> Set String
[precedence_Syn_BExpr] :: Syn_BExpr -> Int
[pretty_Syn_BExpr] :: Syn_BExpr -> String
[self_Syn_BExpr] :: Syn_BExpr -> BExpr
wrap_BExpr :: T_BExpr -> Inh_BExpr -> Syn_BExpr
sem_BExpr_BConst :: Bool -> T_BExpr
sem_BExpr_BVar :: String -> T_BExpr
sem_BExpr_LessThan :: T_IExpr -> T_IExpr -> T_BExpr
sem_BExpr_GreaterThan :: T_IExpr -> T_IExpr -> T_BExpr
sem_BExpr_LessEqual :: T_IExpr -> T_IExpr -> T_BExpr
sem_BExpr_GreaterEqual :: T_IExpr -> T_IExpr -> T_BExpr
sem_BExpr_IEqual :: T_IExpr -> T_IExpr -> T_BExpr
sem_BExpr_BEqual :: T_BExpr -> T_BExpr -> T_BExpr
sem_BExpr_And :: T_BExpr -> T_BExpr -> T_BExpr
sem_BExpr_Or :: T_BExpr -> T_BExpr -> T_BExpr
sem_BExpr_Not :: T_BExpr -> T_BExpr
data Expr
B :: BExpr -> Expr
I :: IExpr -> Expr
sem_Expr :: Expr -> T_Expr
type T_Expr = ((ConstEnv -> Maybe ConstLat), (Set String), String, Expr)
data Inh_Expr
Inh_Expr :: Inh_Expr
data Syn_Expr
Syn_Expr :: (ConstEnv -> Maybe ConstLat) -> Set String -> String -> Expr -> Syn_Expr
[constantPropagation_Syn_Expr] :: Syn_Expr -> ConstEnv -> Maybe ConstLat
[freeVars_Syn_Expr] :: Syn_Expr -> Set String
[pretty_Syn_Expr] :: Syn_Expr -> String
[self_Syn_Expr] :: Syn_Expr -> Expr
wrap_Expr :: T_Expr -> Inh_Expr -> Syn_Expr
sem_Expr_B :: T_BExpr -> T_Expr
sem_Expr_I :: T_IExpr -> T_Expr
type Exprs = [Expr]
sem_Exprs :: Exprs -> T_Exprs
type T_Exprs = (([ConstEnv -> Maybe ConstLat]), ([Set String]), String, Exprs)
data Inh_Exprs
Inh_Exprs :: Inh_Exprs
data Syn_Exprs
Syn_Exprs :: [ConstEnv -> Maybe ConstLat] -> [Set String] -> String -> Exprs -> Syn_Exprs
[constantPropagation_Syn_Exprs] :: Syn_Exprs -> [ConstEnv -> Maybe ConstLat]
[freeVars_Syn_Exprs] :: Syn_Exprs -> [Set String]
[pretty_Syn_Exprs] :: Syn_Exprs -> String
[self_Syn_Exprs] :: Syn_Exprs -> Exprs
wrap_Exprs :: T_Exprs -> Inh_Exprs -> Syn_Exprs
sem_Exprs_Cons :: T_Expr -> T_Exprs -> T_Exprs
sem_Exprs_Nil :: T_Exprs
data IExpr
IConst :: Int -> IExpr
Var :: String -> IExpr
Plus :: IExpr -> IExpr -> IExpr
Minus :: IExpr -> IExpr -> IExpr
Times :: IExpr -> IExpr -> IExpr
Divide :: IExpr -> IExpr -> IExpr
Deref :: IExpr -> IExpr
sem_IExpr :: IExpr -> T_IExpr
type T_IExpr = ((ConstEnv -> Maybe ConstLat), (Set String), Int, String, IExpr)
data Inh_IExpr
Inh_IExpr :: Inh_IExpr
data Syn_IExpr
Syn_IExpr :: (ConstEnv -> Maybe ConstLat) -> Set String -> Int -> String -> IExpr -> Syn_IExpr
[constantPropagation_Syn_IExpr] :: Syn_IExpr -> ConstEnv -> Maybe ConstLat
[freeVars_Syn_IExpr] :: Syn_IExpr -> Set String
[precedence_Syn_IExpr] :: Syn_IExpr -> Int
[pretty_Syn_IExpr] :: Syn_IExpr -> String
[self_Syn_IExpr] :: Syn_IExpr -> IExpr
wrap_IExpr :: T_IExpr -> Inh_IExpr -> Syn_IExpr
sem_IExpr_IConst :: Int -> T_IExpr
sem_IExpr_Var :: String -> T_IExpr
sem_IExpr_Plus :: T_IExpr -> T_IExpr -> T_IExpr
sem_IExpr_Minus :: T_IExpr -> T_IExpr -> T_IExpr
sem_IExpr_Times :: T_IExpr -> T_IExpr -> T_IExpr
sem_IExpr_Divide :: T_IExpr -> T_IExpr -> T_IExpr
sem_IExpr_Deref :: T_IExpr -> T_IExpr
data Proc
Proc :: String -> [String] -> String -> Stat -> Proc
sem_Proc :: Proc -> T_Proc
type T_Proc = Int -> (((String, Proc'')), Int, Proc', Proc)
data Inh_Proc
Inh_Proc :: Int -> Inh_Proc
[label_Inh_Proc] :: Inh_Proc -> Int
data Syn_Proc
Syn_Proc :: (String, Proc'') -> Int -> Proc' -> Proc -> Syn_Proc
[dStar_Syn_Proc] :: Syn_Proc -> (String, Proc'')
[label_Syn_Proc] :: Syn_Proc -> Int
[labelled_Syn_Proc] :: Syn_Proc -> Proc'
[self_Syn_Proc] :: Syn_Proc -> Proc
wrap_Proc :: T_Proc -> Inh_Proc -> Syn_Proc
sem_Proc_Proc :: String -> [String] -> String -> T_Stat -> T_Proc
data Proc'
Proc' :: Int -> Int -> String -> [String] -> String -> Stat' -> Proc'
sem_Proc' :: Proc' -> T_Proc'
type T_Proc' = DStar -> ((DifTrans ConstBranchLat), (DifTrans PtConstLat), (Set Int), (Set Edge), Int, (Set Inter), ([String]), Proc', (DifTrans (Set String)))
data Inh_Proc'
Inh_Proc' :: DStar -> Inh_Proc'
[dStar_Inh_Proc'] :: Inh_Proc' -> DStar
data Syn_Proc'
Syn_Proc' :: DifTrans ConstBranchLat -> DifTrans PtConstLat -> Set Int -> Set Edge -> Int -> Set Inter -> [String] -> Proc' -> DifTrans (Set String) -> Syn_Proc'
[constBranchT_Syn_Proc'] :: Syn_Proc' -> DifTrans ConstBranchLat
[constantPropagation_Syn_Proc'] :: Syn_Proc' -> DifTrans PtConstLat
[final_Syn_Proc'] :: Syn_Proc' -> Set Int
[flow_Syn_Proc'] :: Syn_Proc' -> Set Edge
[init_Syn_Proc'] :: Syn_Proc' -> Int
[interflow_Syn_Proc'] :: Syn_Proc' -> Set Inter
[pretty_Syn_Proc'] :: Syn_Proc' -> [String]
[self_Syn_Proc'] :: Syn_Proc' -> Proc'
[strongLive_Syn_Proc'] :: Syn_Proc' -> DifTrans (Set String)
wrap_Proc' :: T_Proc' -> Inh_Proc' -> Syn_Proc'
sem_Proc'_Proc' :: Int -> Int -> String -> [String] -> String -> T_Stat' -> T_Proc'
type Procs = [Proc]
sem_Procs :: Procs -> T_Procs
type T_Procs = Int -> (DStar, Int, Procs', Procs)
data Inh_Procs
Inh_Procs :: Int -> Inh_Procs
[label_Inh_Procs] :: Inh_Procs -> Int
data Syn_Procs
Syn_Procs :: DStar -> Int -> Procs' -> Procs -> Syn_Procs
[dStar_Syn_Procs] :: Syn_Procs -> DStar
[label_Syn_Procs] :: Syn_Procs -> Int
[labelled_Syn_Procs] :: Syn_Procs -> Procs'
[self_Syn_Procs] :: Syn_Procs -> Procs
wrap_Procs :: T_Procs -> Inh_Procs -> Syn_Procs
sem_Procs_Cons :: T_Proc -> T_Procs -> T_Procs
sem_Procs_Nil :: T_Procs
type Procs' = [Proc']
sem_Procs' :: Procs' -> T_Procs'
type T_Procs' = DStar -> ((DifTrans ConstBranchLat), (DifTrans PtConstLat), (Set Edge), (Set Inter), ([String]), Procs', (DifTrans (Set String)))
data Inh_Procs'
Inh_Procs' :: DStar -> Inh_Procs'
[dStar_Inh_Procs'] :: Inh_Procs' -> DStar
data Syn_Procs'
Syn_Procs' :: DifTrans ConstBranchLat -> DifTrans PtConstLat -> Set Edge -> Set Inter -> [String] -> Procs' -> DifTrans (Set String) -> Syn_Procs'
[constBranchT_Syn_Procs'] :: Syn_Procs' -> DifTrans ConstBranchLat
[constantPropagation_Syn_Procs'] :: Syn_Procs' -> DifTrans PtConstLat
[flow_Syn_Procs'] :: Syn_Procs' -> Set Edge
[interflow_Syn_Procs'] :: Syn_Procs' -> Set Inter
[pretty_Syn_Procs'] :: Syn_Procs' -> [String]
[self_Syn_Procs'] :: Syn_Procs' -> Procs'
[strongLive_Syn_Procs'] :: Syn_Procs' -> DifTrans (Set String)
wrap_Procs' :: T_Procs' -> Inh_Procs' -> Syn_Procs'
sem_Procs'_Cons :: T_Proc' -> T_Procs' -> T_Procs'
sem_Procs'_Nil :: T_Procs'
data Program
Program :: Procs -> Stat -> Program
sem_Program :: Program -> T_Program
type T_Program = (Program', Program)
data Inh_Program
Inh_Program :: Inh_Program
data Syn_Program
Syn_Program :: Program' -> Program -> Syn_Program
[labelled_Syn_Program] :: Syn_Program -> Program'
[self_Syn_Program] :: Syn_Program -> Program
wrap_Program :: T_Program -> Inh_Program -> Syn_Program
sem_Program_Program :: T_Procs -> T_Stat -> T_Program
data Program'
Program' :: Procs' -> Stat' -> DStar -> Program'
sem_Program' :: Program' -> T_Program'
type T_Program' = ((DifTrans ConstBranchLat), (DifTrans PtConstLat), (Set Int), (Set Edge), Int, (Set Inter), String, Program', (DifTrans (Set String)))
data Inh_Program'
Inh_Program' :: Inh_Program'
data Syn_Program'
Syn_Program' :: DifTrans ConstBranchLat -> DifTrans PtConstLat -> Set Int -> Set Edge -> Int -> Set Inter -> String -> Program' -> DifTrans (Set String) -> Syn_Program'
[constBranchT_Syn_Program'] :: Syn_Program' -> DifTrans ConstBranchLat
[constantPropagation_Syn_Program'] :: Syn_Program' -> DifTrans PtConstLat
[final_Syn_Program'] :: Syn_Program' -> Set Int
[flow_Syn_Program'] :: Syn_Program' -> Set Edge
[init_Syn_Program'] :: Syn_Program' -> Int
[interflow_Syn_Program'] :: Syn_Program' -> Set Inter
[pretty_Syn_Program'] :: Syn_Program' -> String
[self_Syn_Program'] :: Syn_Program' -> Program'
[strongLive_Syn_Program'] :: Syn_Program' -> DifTrans (Set String)
wrap_Program' :: T_Program' -> Inh_Program' -> Syn_Program'
sem_Program'_Program' :: T_Procs' -> T_Stat' -> DStar -> T_Program'
data Stat
Skip :: Stat
IfThenElse :: BExpr -> Stat -> Stat -> Stat
While :: BExpr -> Stat -> Stat
Print :: Expr -> Stat
Call :: String -> Exprs -> String -> Stat
IAssign :: String -> IExpr -> Stat
BAssign :: String -> BExpr -> Stat
Seq :: Stat -> Stat -> Stat
Malloc :: String -> IExpr -> Stat
Free :: IExpr -> Stat
RefAssign :: IExpr -> IExpr -> Stat
Continue :: Stat
Break :: Stat
sem_Stat :: Stat -> T_Stat
type T_Stat = Int -> (Int, Stat', Stat)
data Inh_Stat
Inh_Stat :: Int -> Inh_Stat
[label_Inh_Stat] :: Inh_Stat -> Int
data Syn_Stat
Syn_Stat :: Int -> Stat' -> Stat -> Syn_Stat
[label_Syn_Stat] :: Syn_Stat -> Int
[labelled_Syn_Stat] :: Syn_Stat -> Stat'
[self_Syn_Stat] :: Syn_Stat -> Stat
wrap_Stat :: T_Stat -> Inh_Stat -> Syn_Stat
sem_Stat_Skip :: T_Stat
sem_Stat_IfThenElse :: BExpr -> T_Stat -> T_Stat -> T_Stat
sem_Stat_While :: BExpr -> T_Stat -> T_Stat
sem_Stat_Print :: Expr -> T_Stat
sem_Stat_Call :: String -> Exprs -> String -> T_Stat
sem_Stat_IAssign :: String -> IExpr -> T_Stat
sem_Stat_BAssign :: String -> BExpr -> T_Stat
sem_Stat_Seq :: T_Stat -> T_Stat -> T_Stat
sem_Stat_Malloc :: String -> IExpr -> T_Stat
sem_Stat_Free :: IExpr -> T_Stat
sem_Stat_RefAssign :: IExpr -> IExpr -> T_Stat
sem_Stat_Continue :: T_Stat
sem_Stat_Break :: T_Stat
data Stat'
Skip' :: Int -> Stat'
IfThenElse' :: Int -> BExpr -> Stat' -> Stat' -> Stat'
While' :: Int -> BExpr -> Stat' -> Stat'
Print' :: Int -> Expr -> Stat'
Call' :: Int -> Int -> String -> Exprs -> String -> Stat'
IAssign' :: Int -> String -> IExpr -> Stat'
BAssign' :: Int -> String -> BExpr -> Stat'
Seq' :: Stat' -> Stat' -> Stat'
Malloc' :: Int -> String -> IExpr -> Stat'
Free' :: Int -> IExpr -> Stat'
RefAssign' :: Int -> IExpr -> IExpr -> Stat'
Continue' :: Int -> Stat'
Break' :: Int -> Stat'
sem_Stat' :: Stat' -> T_Stat'
type T_Stat' = (Maybe Int) -> DStar -> (Maybe Int) -> ((Set Int), (DifTrans ConstBranchLat), (DifTrans PtConstLat), (Set Int), (Set Edge), Int, (Set Inter), Bool, Bool, ([String]), Stat', (DifTrans (Set String)))
data Inh_Stat'
Inh_Stat' :: Maybe Int -> DStar -> Maybe Int -> Inh_Stat'
[continueLabel_Inh_Stat'] :: Inh_Stat' -> Maybe Int
[dStar_Inh_Stat'] :: Inh_Stat' -> DStar
[successor_Inh_Stat'] :: Inh_Stat' -> Maybe Int
data Syn_Stat'
Syn_Stat' :: Set Int -> DifTrans ConstBranchLat -> DifTrans PtConstLat -> Set Int -> Set Edge -> Int -> Set Inter -> Bool -> Bool -> [String] -> Stat' -> DifTrans (Set String) -> Syn_Stat'
[breakLabels_Syn_Stat'] :: Syn_Stat' -> Set Int
[constBranchT_Syn_Stat'] :: Syn_Stat' -> DifTrans ConstBranchLat
[constantPropagation_Syn_Stat'] :: Syn_Stat' -> DifTrans PtConstLat
[final_Syn_Stat'] :: Syn_Stat' -> Set Int
[flow_Syn_Stat'] :: Syn_Stat' -> Set Edge
[init_Syn_Stat'] :: Syn_Stat' -> Int
[interflow_Syn_Stat'] :: Syn_Stat' -> Set Inter
[isSingle_Syn_Stat'] :: Syn_Stat' -> Bool
[isSkip_Syn_Stat'] :: Syn_Stat' -> Bool
[pretty_Syn_Stat'] :: Syn_Stat' -> [String]
[self_Syn_Stat'] :: Syn_Stat' -> Stat'
[strongLive_Syn_Stat'] :: Syn_Stat' -> DifTrans (Set String)
wrap_Stat' :: T_Stat' -> Inh_Stat' -> Syn_Stat'
sem_Stat'_Skip' :: Int -> T_Stat'
sem_Stat'_IfThenElse' :: Int -> T_BExpr -> T_Stat' -> T_Stat' -> T_Stat'
sem_Stat'_While' :: Int -> T_BExpr -> T_Stat' -> T_Stat'
sem_Stat'_Print' :: Int -> T_Expr -> T_Stat'
sem_Stat'_Call' :: Int -> Int -> String -> T_Exprs -> String -> T_Stat'
sem_Stat'_IAssign' :: Int -> String -> T_IExpr -> T_Stat'
sem_Stat'_BAssign' :: Int -> String -> T_BExpr -> T_Stat'
sem_Stat'_Seq' :: T_Stat' -> T_Stat' -> T_Stat'
sem_Stat'_Malloc' :: Int -> String -> T_IExpr -> T_Stat'
sem_Stat'_Free' :: Int -> T_IExpr -> T_Stat'
sem_Stat'_RefAssign' :: Int -> T_IExpr -> T_IExpr -> T_Stat'
sem_Stat'_Continue' :: Int -> T_Stat'
sem_Stat'_Break' :: Int -> T_Stat'
instance GHC.Show.Show AttributeGrammar.IExpr
instance GHC.Classes.Eq AttributeGrammar.IExpr
instance GHC.Show.Show AttributeGrammar.BExpr
instance GHC.Classes.Eq AttributeGrammar.BExpr
instance GHC.Show.Show AttributeGrammar.Expr
instance GHC.Classes.Eq AttributeGrammar.Expr
instance GHC.Show.Show AttributeGrammar.Stat
instance GHC.Show.Show AttributeGrammar.Proc
instance GHC.Show.Show AttributeGrammar.Program
instance GHC.Show.Show AttributeGrammar.Stat'
instance GHC.Show.Show AttributeGrammar.Proc'
instance GHC.Show.Show AttributeGrammar.Program'

module Parser
newtype HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
HappyAbsSyn :: HappyAny -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
type HappyAny = Any
happyIn4 :: t4 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut4 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t4
happyIn5 :: t5 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut5 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t5
happyIn6 :: t6 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut6 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t6
happyIn7 :: t7 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut7 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t7
happyIn8 :: t8 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut8 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t8
happyIn9 :: t9 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut9 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t9
happyIn10 :: t10 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut10 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t10
happyIn11 :: t11 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut11 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t11
happyIn12 :: t12 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut12 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t12
happyIn13 :: t13 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut13 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t13
happyIn14 :: t14 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut14 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t14
happyIn15 :: t15 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut15 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t15
happyIn16 :: t16 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut16 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t16
happyIn17 :: t17 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut17 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t17
happyIn18 :: t18 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut18 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t18
happyIn19 :: t19 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut19 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t19
happyIn20 :: t20 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOut20 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> t20
happyInTok :: Token -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyOutTok :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 -> Token
happyExpList :: HappyAddr
happyExpListPerState :: IsString a => Int -> [a]
happyActOffsets :: HappyAddr
happyGotoOffsets :: HappyAddr
happyAdjustOffset :: Int# -> Int#
happyDefActions :: HappyAddr
happyCheck :: HappyAddr
happyTable :: HappyAddr
happyReduceArr :: Array Int (Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr))
happy_n_terms :: Int
happy_n_nonterms :: Int
happyReduce_1 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_1 :: HappyAbsSyn t1 t2 t3 t5 t21 t22 t23 t24 t25 t26 t27 t28 t29 t30 t31 t32 t33 -> HappyAbsSyn t2 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49
happyReduce_2 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_2 :: HappyStk (HappyAbsSyn t4 Program [Proc] t7 t8 t9 t10 t11 Stat t13 t14 t15 t16 t17 t18 t19 t20) -> HappyStk (HappyAbsSyn t4 Program [Proc] t7 t8 t9 t10 t11 Stat t13 t14 t15 t16 t17 t18 t19 t20)
happyReduce_3 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_3 :: HappyAbsSyn t1 t2 t6 a t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 -> HappyAbsSyn t37 t38 [a] t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 -> HappyAbsSyn t53 t54 [a] t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t67 t68
happyReduce_4 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_4 :: HappyAbsSyn t4 t5 [a] t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyReduce_5 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_5 :: HappyStk (HappyAbsSyn t4 t5 t6 Proc [String] [Char] t10 t11 Stat t13 t14 t15 t16 t17 t18 t19 t20) -> HappyStk (HappyAbsSyn t4 t5 t6 Proc [String] [Char] t10 t11 Stat t13 t14 t15 t16 t17 t18 t19 t20)
happyReduce_6 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_6 :: p1 -> HappyAbsSyn t1 t2 t3 t10 t21 t22 t23 t24 t25 t26 t27 t28 t29 t30 t31 t32 t33 -> p2 -> HappyAbsSyn t34 t35 t36 t37 t23 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49
happyReduce_7 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_7 :: HappyAbsSyn t4 t5 t6 t7 [a] t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20
happyReduce_8 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_8 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 -> p -> HappyAbsSyn t39 t40 t41 t42 t43 t29 t44 t11 t45 t46 t47 t48 t49 t50 t51 t52 t53
happyReduce_9 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_9 :: HappyAbsSyn t1 t2 t3 t10 t21 t22 t23 a t24 t25 t26 t27 t28 t29 t30 t31 t32 -> p -> HappyAbsSyn t33 t34 t35 t36 t37 t38 [a] t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 -> HappyAbsSyn t49 t50 t51 t52 t53 t54 [a] t55 t56 t57 t58 t59 t60 t61 t62 t63 t64
happyReduce_10 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_10 :: HappyAbsSyn t1 t2 t3 t10 t11 t22 t23 a t24 t25 t26 t27 t28 t29 t30 t31 t32 -> HappyAbsSyn t33 t34 t35 t36 t37 t38 [a] t39 t40 t41 t42 t43 t44 t45 t46 t47 t48
happyReduce_11 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_11 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t11 t29 t30 t31 t32 t33 t34 t35 t36 t37 -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 String t45 t46 t47 t48 t49 t50 t51 t52 t53
happyReduce_12 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_12 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t12 Stat t30 t31 t32 t33 t34 t35 t36 -> HappyAbsSyn t37 t38 t39 t40 t41 t42 t43 t44 Stat t45 t46 t47 t48 t49 t50 t51 t52 -> HappyAbsSyn t53 t54 t55 t56 t57 t58 t59 t60 Stat t61 t62 t63 t64 t65 t66 t67 t68
happyReduce_13 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_13 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 -> HappyAbsSyn t39 t40 t41 t42 t43 t44 t45 t46 t31 t13 t47 t48 t49 t50 t51 t52 t53
happyReduce_14 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_14 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 Stat Stat t15 t16 t17 t18 BExpr t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 Stat Stat t15 t16 t17 t18 BExpr t20)
happyReduce_15 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_15 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 Stat Stat t15 t16 t17 t18 BExpr t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 Stat Stat t15 t16 t17 t18 BExpr t20)
happyReduce_16 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_16 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 Stat Stat t15 t16 t17 t18 BExpr t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 Stat Stat t15 t16 t17 t18 BExpr t20)
happyReduce_17 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_17 :: HappyAbsSyn t1 t2 t3 t14 t21 t22 t23 t24 t25 t26 t27 t28 t29 t30 t31 t32 t33 -> HappyAbsSyn t34 t35 t36 t37 t38 t39 t40 t41 t42 t27 t43 t44 t45 t46 t47 t48 t49
happyReduce_18 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_18 :: p1 -> p2 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 t17 t18 t19 t20
happyReduce_19 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_19 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 IExpr t18 t19 t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 IExpr t18 t19 t20)
happyReduce_20 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_20 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 t17 t18 BExpr t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 t17 t18 BExpr t20)
happyReduce_21 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_21 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 Expr t17 t18 t19 t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 Expr t17 t18 t19 t20)
happyReduce_22 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_22 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 t17 IExpr t19 t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 t17 IExpr t19 t20)
happyReduce_23 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_23 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat [Expr] t16 t17 t18 t19 t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat [Expr] t16 t17 t18 t19 t20)
happyReduce_24 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_24 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 IExpr t18 t19 t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 IExpr t18 t19 t20)
happyReduce_25 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_25 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 t17 IExpr t19 t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 t17 IExpr t19 t20)
happyReduce_26 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_26 :: p1 -> HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 -> p2 -> HappyAbsSyn t39 t40 t41 t42 t43 t44 t45 t46 t12 t47 t30 t48 t49 t50 t51 t52 t53
happyReduce_27 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_27 :: p1 -> HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 -> p2 -> HappyAbsSyn t39 t40 t41 t42 t43 t44 t45 t46 t12 t47 t30 t48 t49 t50 t51 t52 t53
happyReduce_28 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_28 :: p1 -> p2 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 t17 t18 t19 t20
happyReduce_29 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_29 :: p1 -> p2 -> HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 t17 t18 t19 t20
happyReduce_30 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_30 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 IExpr t18 t19 t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 IExpr t18 t19 t20)
happyReduce_31 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_31 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 IExpr IExpr t19 t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 Stat t15 t16 IExpr IExpr t19 t20)
happyReduce_32 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_32 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t15 a t33 t34 t35 t36 -> p -> HappyAbsSyn t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 [a] t48 t49 t50 t51 t52 -> HappyAbsSyn t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 [a] t64 t65 t66 t67 t68
happyReduce_33 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_33 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t15 a t33 t34 t35 t36 -> HappyAbsSyn t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 [a] t16 t48 t49 t50 t51
happyReduce_34 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_34 :: HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 [a] t16 t17 t18 t19 t20
happyReduce_35 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_35 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t16 IExpr t34 t35 t36 -> HappyAbsSyn t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 Expr t17 t49 t50 t51
happyReduce_36 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_36 :: HappyAbsSyn t1 t2 t3 t19 t21 t22 t23 t24 t25 t26 t27 t28 t16 t29 t30 BExpr t31 -> HappyAbsSyn t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 Expr t44 t45 t46 t47
happyReduce_37 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_37 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 IExpr t35 t36 t37 -> p -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 IExpr t51 t52 t53 -> HappyAbsSyn t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 IExpr t67 t68 t69
happyReduce_38 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_38 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 IExpr t35 t36 t37 -> p -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 IExpr t51 t52 t53 -> HappyAbsSyn t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 IExpr t67 t68 t69
happyReduce_39 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_39 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 IExpr t35 t36 t37 -> p -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 IExpr t51 t52 t53 -> HappyAbsSyn t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 IExpr t67 t68 t69
happyReduce_40 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_40 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 IExpr t35 t36 t37 -> p -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 IExpr t51 t52 t53 -> HappyAbsSyn t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 IExpr t67 t68 t69
happyReduce_41 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_41 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 -> HappyAbsSyn t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t36 t18 t52 t53
happyReduce_42 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_42 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t18 t36 t37 -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 IExpr t52 t53
happyReduce_43 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_43 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t18 t36 t37 -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 IExpr t52 t53
happyReduce_44 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_44 :: p1 -> HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 -> p2 -> HappyAbsSyn t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t17 t35 t52 t53
happyReduce_45 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_45 :: p1 -> HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 -> p2 -> HappyAbsSyn t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t17 t35 t52 t53
happyReduce_46 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_46 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 IExpr t36 t37 -> p -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 IExpr t52 t53
happyReduce_47 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_47 :: HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 IExpr IExpr t19 t20) -> HappyStk (HappyAbsSyn t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 IExpr IExpr t19 t20)
happyReduce_48 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_48 :: HappyAbsSyn t1 t2 t3 t19 t21 t22 t23 t24 t25 t26 t27 t28 t29 t30 t31 BExpr t32 -> p -> HappyAbsSyn t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 BExpr t48
happyReduce_49 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_49 :: HappyAbsSyn t1 t2 t3 t19 t21 t22 t23 t24 t25 t26 t27 t28 t29 t30 t31 BExpr t32 -> p -> HappyAbsSyn t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 BExpr t48 -> HappyAbsSyn t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 BExpr t64
happyReduce_50 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_50 :: HappyAbsSyn t1 t2 t3 t19 t21 t22 t23 t24 t25 t26 t27 t28 t29 t30 t31 BExpr t32 -> p -> HappyAbsSyn t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 BExpr t48 -> HappyAbsSyn t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 BExpr t64
happyReduce_51 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_51 :: HappyAbsSyn t1 t2 t3 t19 t21 t22 t23 t24 t25 t26 t27 t28 t29 t30 t31 BExpr t32 -> p -> HappyAbsSyn t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 BExpr t48 -> HappyAbsSyn t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 BExpr t64
happyReduce_52 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_52 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 IExpr t35 t36 t37 -> p -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 IExpr t51 t52 t53 -> HappyAbsSyn t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t17 t67 BExpr t68
happyReduce_53 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_53 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 IExpr t35 t36 t37 -> p -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 IExpr t51 t52 t53 -> HappyAbsSyn t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t17 t67 BExpr t68
happyReduce_54 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_54 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 IExpr t35 t36 t37 -> p -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 IExpr t51 t52 t53 -> HappyAbsSyn t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t17 t67 BExpr t68
happyReduce_55 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_55 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 IExpr t35 t36 t37 -> p -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 IExpr t51 t52 t53 -> HappyAbsSyn t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t17 t67 BExpr t68
happyReduce_56 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_56 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 IExpr t35 t36 t37 -> p -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 IExpr t51 t52 t53 -> HappyAbsSyn t54 t55 t56 t57 t58 t59 t60 t61 t62 t63 t64 t65 t66 t17 t67 BExpr t68
happyReduce_57 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_57 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 -> HappyAbsSyn t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t38 t20
happyReduce_58 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_58 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t20 -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 BExpr
happyReduce_59 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_59 :: HappyAbsSyn t1 t2 t3 t25 t26 t27 t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t20 -> HappyAbsSyn t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 BExpr
happyReduce_60 :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduction_60 :: p1 -> HappyAbsSyn t1 t2 t3 t19 t21 t22 t23 t24 t25 t26 t27 t28 t29 t30 t31 t32 t33 -> p2 -> HappyAbsSyn t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t32
happyNewToken :: Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyError_ :: [String] -> Int# -> Token -> [Token] -> HappyIdentity a
newtype HappyIdentity a
HappyIdentity :: a -> HappyIdentity a
happyIdentity :: a -> HappyIdentity a
happyRunIdentity :: HappyIdentity a -> a
happyThen :: () => HappyIdentity a -> (a -> HappyIdentity b) -> HappyIdentity b
happyReturn :: () => a -> HappyIdentity a
happyThen1 :: Monad m => m t1 -> (t1 -> t2 -> m b) -> t2 -> m b
happyReturn1 :: () => a -> b -> HappyIdentity a
happyError' :: () => ([Token], [String]) -> HappyIdentity a
happy :: [Token] -> Program
happySeq :: a -> b -> b
parseError :: [Token] -> a
data Happy_IntList
HappyCons :: Int# -> Happy_IntList -> Happy_IntList
data HappyStk a
HappyStk :: a -> HappyStk a -> HappyStk a
infixr 9 `HappyStk`
infixr 9 `HappyStk`
happyParse :: Int# -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyAccept :: Int# -> p1 -> Int# -> p2 -> HappyStk a -> b -> HappyIdentity a
happyDoAction :: Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
indexShortOffAddr :: HappyAddr -> Int# -> Int#
happyLt :: Int# -> Int# -> Bool
readArrayBit :: HappyAddr -> Int -> Bool
data HappyAddr
HappyA# :: Addr# -> HappyAddr
happyShift :: Int# -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happySpecReduce_0 :: Int# -> HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happySpecReduce_1 :: Int# -> (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr -> HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happySpecReduce_2 :: Int# -> (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] [Char] Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr -> HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr -> HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happySpecReduce_3 :: Int# -> (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr -> HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr -> HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr -> HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyReduce :: Int# -> Int# -> (HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyMonadReduce :: Int# -> Int# -> (HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> Token -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyMonad2Reduce :: Int# -> Int# -> (HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> Token -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)) -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyDrop :: Int# -> Happy_IntList -> Happy_IntList
happyDropStk :: Int# -> HappyStk a -> HappyStk a
happyGoto :: Int# -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
happyFail :: [String] -> Int# -> Token -> Int# -> Happy_IntList -> HappyStk (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr) -> [Token] -> HappyIdentity (HappyAbsSyn Program Program [Proc] Proc [String] [Char] [String] String Stat Stat Stat [Expr] Expr IExpr IExpr BExpr BExpr)
notHappyAtAll :: a
happyTcHack :: Int# -> a -> a
happyDoSeq :: a -> b -> b
happyDontSeq :: a -> b -> b
instance GHC.Base.Functor Parser.HappyIdentity
instance GHC.Base.Applicative Parser.HappyIdentity
instance GHC.Base.Monad Parser.HappyIdentity

module AnalysesConversion
data Dir
Forward :: Dir
Backward :: Dir
data Flow
Flow :: Int -> Set Int -> Set Edge -> Set Inter -> Flow
[initial] :: Flow -> Int
[finals] :: Flow -> Set Int
[edges] :: Flow -> Set Edge
[interflow] :: Flow -> Set Inter
data Analysis p
Analysis :: Dir -> DifTrans p -> p -> Analysis p
[direction] :: Analysis p -> Dir
[difTrans] :: Analysis p -> DifTrans p
[extremal] :: Analysis p -> p
swap :: (a, b) -> (b, a)

-- | Unpack a flow into a tuple of extremals, edges, and interflow edges.
--   Reverses the necessary components for backwards flows.
unpackFlow :: Bool -> Flow -> (Set Int, Set Edge, Set Inter)

-- | Equivalent of python's groupby: for each <tt>fst</tt> element occuring
--   in the list, gather all <tt>snd</tt>'s belonging to tuples with
--   matching <tt>fst</tt> into a list
group :: (Ord a, Ord b) => [(a, b)] -> Map a (Set b)

-- | Combine an analysis and a flow into a monotone framework
analysisToFramework :: Analysis p -> Flow -> MonotoneFramework p
instance GHC.Classes.Eq AnalysesConversion.Dir
instance GHC.Show.Show AnalysesConversion.Dir

module Latex

-- | Format and print an analysis result as a latex array
latexPrint :: (Maybe propertySpace -> String) -> (Map Label (ContextSensitive propertySpace), Map Label (ContextSensitive propertySpace), [(Map Label (ContextSensitive propertySpace), [(Label, Label)])]) -> IO ()

-- | Format a table of properties as a latex array, with the given name and
--   property formatter
latexPrinter :: String -> (Maybe propertySpace -> String) -> Map Label (ContextSensitive propertySpace) -> String
constantPropagationTex :: Maybe PtConstLat -> String
constEnvTex :: ConstEnv -> String
constantBranchTex :: Maybe ConstBranchLat -> String
setTex :: (a -> String) -> Set a -> String
strongLiveTex :: Maybe (Set String) -> String

module Compiler
callStringLimit :: Int
compile :: String -> IO ()

-- | "pretty" print a solution to a monotone framework
prettyPrint :: Show propertySpace => Analysis propertySpace -> (Map Label (ContextSensitive propertySpace), Map Label (ContextSensitive propertySpace), [(Map Label (ContextSensitive propertySpace), [(Label, Label)])]) -> IO ()
secondOf3 :: (a, b, c) -> b
