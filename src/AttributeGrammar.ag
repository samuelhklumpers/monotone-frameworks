{
import qualified Data.Map as M
import qualified Data.Maybe as Maybe
import qualified Data.List as L
import Data.Bifunctor
import Data.Set

import MonotoneFrameworks

import Std (Endo(..), coerce)

instance Semigroup Bool where
  False <> x = x
  x <> False = x

instance Monoid Bool where
  mappend = (<>)
  mempty = False

--                isBackward
type DifTrans m = (Bool, (M.Map Int (m -> m), M.Map Int (m -> m -> m)))


insertL :: Int -> (m -> m) -> DifTrans m -> DifTrans m
insertL i f (b, m) = (b, first (M.insert i f) m)

insertR :: Int -> (m -> m -> m) -> DifTrans m -> DifTrans m
insertR i f (b, m) = (b, second (M.insert i f) m)

singleL i x = insertL i x (False, mempty)
singleR i x = insertR i x (False, mempty)

lookupL :: Int -> DifTrans p -> (p -> p)
lookupL i (_, (m, _)) = Maybe.fromJust $ M.lookup i m

lookupR :: Int -> DifTrans p -> (p -> p -> p)
lookupR i (_, (_, m)) = Maybe.fromJust $ M.lookup i m

forwardAnalysis :: DifTrans m
forwardAnalysis  = (False, mempty)

backwardAnalysis :: DifTrans m
backwardAnalysis = (True, mempty)

data Proc'' = Proc'' { procEntry :: Int, procExit :: Int, procName :: String, procInp :: [String], procOut :: String } deriving (Show, Eq, Ord)
type DStar = [(String, Proc'')]

type Edge = (Int, Int)
data Inter = Inter Int Int Int Int deriving (Eq, Ord)

instance Show Inter where
  show (Inter a b c d) = show (a, b, c, d)
}

data Program
  | Program
    procs :: Procs
    stat  :: Stat
  
  deriving Program : Show

data Program'
  | Program'
    procs :: Procs'
    stat :: Stat'
    dStar :: DStar

  deriving Program' : Show

data Proc
  | Proc
    name :: String
    inp :: {[String]}
    out :: String
    stat :: Stat

  deriving Proc : Show

data Proc'
  | Proc'
    labelEntry :: Int
    labelExit :: Int
    name :: String
    inp :: {[String]}
    out :: String 
    stat :: Stat'

  deriving Proc' : Show

data Stat
  | Skip
  | IfThenElse    cond  :: {BExpr}    stat1  :: Stat       stat2 :: Stat
  | While         cond  :: {BExpr}    stat   :: Stat
  | Call          name  :: String     params :: {Exprs}    out :: String
  | IAssign       name  :: String     val    :: {IExpr}
  | BAssign       name  :: String     val    :: {BExpr}
  | Seq           stat1 :: Stat       stat2  :: Stat
  | Malloc        name  :: String     size   :: {IExpr}
  | Free          ptr   :: {IExpr}
  | RefAssign     ptr   :: {IExpr}    val    :: {IExpr}
  | Continue
  | Break
  
  deriving Stat : Show

data Stat'
  | Skip'          label :: Int
  | IfThenElse'    labelc :: Int       cond  :: BExpr      stat1  :: Stat'     stat2 :: Stat'
  | While'         labelc :: Int       cond  :: BExpr      stat   :: Stat'
  | Call'          labelCall :: Int    labelReturn :: Int  name  :: String     params :: Exprs    out :: String
  | IAssign'       label :: Int        name  :: String     val    :: IExpr
  | BAssign'       label :: Int        name  :: String     val    :: BExpr
  | Seq'           stat1 :: Stat'      stat2  :: Stat'
  | Malloc'        label :: Int        name  :: String     size   :: IExpr
  | Free'          label :: Int        ptr   :: IExpr
  | RefAssign'     label :: Int        ptr   :: IExpr      val :: IExpr
  | Continue'      label :: Int
  | Break'         label :: Int

  deriving Stat' : Show


data IExpr 
  | IConst        val  :: Int
  | Var           name :: String
  | Plus          left :: IExpr       right :: IExpr
  | Minus         left :: IExpr       right :: IExpr
  | Times         left :: IExpr       right :: IExpr
  | Divide        left :: IExpr       right :: IExpr
  | Deref         ptr  :: IExpr
deriving IExpr : Eq, Show

data BExpr
  | BConst        val  :: Bool
  | BVar          name :: String
  | LessThan      left :: IExpr       right :: IExpr
  | GreaterThan   left :: IExpr       right :: IExpr
  | LessEqual     left :: IExpr       right :: IExpr
  | GreaterEqual  left :: IExpr       right :: IExpr
  | IEqual        left :: IExpr       right :: IExpr
  | BEqual        left :: BExpr       right :: BExpr
  | And           left :: BExpr       right :: BExpr
  | Or            left :: BExpr       right :: BExpr
  | Not           val  :: BExpr
deriving BExpr : Eq, Show


data Expr | B expr :: BExpr
          | I expr :: IExpr
deriving Expr : Eq, Show

type Procs = [Proc]
type Procs' = [Proc']
type Exprs = [Expr]

-- * Create a labelled AST

attr Proc Procs Stat [ | label :: Int | ]

attr Program [ | | labelled :: Program' ]
attr Proc    [ | | labelled :: Proc'  dStar :: { (String, Proc'') } ]
attr Procs   [ | | labelled :: Procs'  dStar :: DStar ]
attr Stat    [ | | labelled :: Stat'    ]

sem Program
  | Program
    procs.label  = 1
    stat.label   = @procs.label
    lhs.labelled = Program' @procs.labelled @stat.labelled @procs.dStar

sem Procs
  | Nil
    lhs.labelled = []
    lhs.dStar = []
  | Cons
    lhs.labelled = @hd.labelled : @tl.labelled
    lhs.dStar = @hd.dStar : @tl.dStar

sem Proc
  | Proc
    stat.label   = @lhs.label + 1
    lhs.labelled = Proc' @lhs.label @stat.label @name @inp @out @stat.labelled
    lhs.label    = @stat.label + 1
    lhs.dStar    = (@name, Proc'' @lhs.label @stat.label @name @inp @out)

sem Stat
  | Skip
    lhs.label    = @lhs.label + 1
    lhs.labelled = Skip' @lhs.label

  | IfThenElse
    stat1.label  = @lhs.label + 1 -- lhs.label is the label of the conditional.
    stat2.label  = @stat1.label
    lhs.label    = @stat2.label
    lhs.labelled = IfThenElse' @lhs.label @cond @stat1.labelled @stat2.labelled

  | While
    stat.label   = @lhs.label + 1 -- lhs.label is the label of the conditional.
    lhs.label    = @stat.label
    lhs.labelled = While' @lhs.label @cond @stat.labelled

  | Call
    lhs.label    = @lhs.label + 2 -- Entry and exit label
    lhs.labelled = Call' @lhs.label (@lhs.label + 1) @name @params @out

  | IAssign
    lhs.label    = @lhs.label + 1
    lhs.labelled = IAssign' @lhs.label @name @val

  | BAssign
    lhs.label    = @lhs.label + 1
    lhs.labelled = BAssign' @lhs.label @name @val

  | Seq
    stat1.label  = @lhs.label
    stat2.label  = @stat1.label
    lhs.labelled = Seq' @stat1.labelled @stat2.labelled

  | Malloc
    lhs.label    = @lhs.label + 1
    lhs.labelled = Malloc' @lhs.label @name @size

  | Free
    lhs.label    = @lhs.label + 1
    lhs.labelled = Free' @lhs.label @ptr

  | RefAssign
    lhs.label    = @lhs.label + 1
    lhs.labelled = RefAssign' @lhs.label @ptr @val

  | Continue
    lhs.label    = @lhs.label + 1
    lhs.labelled = Continue' @lhs.label

  | Break
    lhs.label    = @lhs.label + 1
    lhs.labelled = Break' @lhs.label

{
data ConstLat = CI Int | CB Bool | NonConst deriving (Show, Eq)
newtype PtConstLat = PtConstLat (M.Map String ConstLat)

instance Semigroup ConstLat where
  CI x <> CI y = if x == y then CI x else NonConst
  CB x <> CB y = if x == y then CB x else NonConst
  _    <> _       = NonConst

instance Monoid ConstLat where
  mempty = NonConst

instance BoundedSemiLattice PtConstLat where

}

-- * Pretty printer
attr Program'           [ | | pretty :: String  init :: Int  final :: { Set Int }  flow :: { Set Edge }  interflow :: { Set Inter }  strongLive :: { DifTrans (Set String) }  valSpace :: { DifTrans PtConstLat } ]
attr Proc' Stat'        [ dStar :: DStar | | pretty :: { [String] }  init :: Int  final :: { Set Int }  flow :: { Set Edge }  interflow use {<>} {mempty} :: { Set Inter } ]
attr Procs'             [ dStar :: DStar | | pretty :: { [String] }  flow :: { Set Edge }  interflow use {<>} {mempty} :: { Set Inter } ]
attr IExpr BExpr        [ | | pretty :: String  precedence :: Int  freeVars use {<>} {empty} :: { Set String }  expValSpace :: { PtConstLat -> ConstLat } ]
attr Expr               [ | | freeVars use {<>} {empty} :: { Set String }  expValSpace :: { PtConstLat -> ConstLat }  ]
attr Exprs              [ | | freeVars use {:} {[]} :: { [Set String] }   expValSpace use {:} {[]} :: { [PtConstLat -> ConstLat] }  ]  
attr Expr Exprs         [ | | pretty :: String   ]
attr Stat'              [ | continueLabel :: { Maybe Int } | isSkip :: Bool  isSingle :: Bool  breakLabels use {<>} {empty} :: { Set Int }  ]
attr Procs' Proc' Stat'  [ | | strongLive use {<>} {backwardAnalysis} :: { DifTrans (Set String) }  valSpace use {<>} {forwardAnalysis} :: { DifTrans PtConstLat }  ]

{
indent :: [String] -> [String]
indent = fmap ("  " ++)

showLabel :: Int -> String
showLabel label = "\ESC[93m" ++ reverse (go label) ++ "\ESC[0m"
  where
    go :: Int -> String
    go x
      | x < 0     = error "Negative label"
      | r == 0    = subscript !! m : ""
      | otherwise = subscript !! m : go r
      where
        (r, m) = x `divMod` 10
    subscript = "₀₁₂₃₄₅₆₇₈₉"

addSemicolon :: [String] -> [String]
addSemicolon [] = []
addSemicolon xs = init xs ++ [last xs ++ ";"]

findProc :: String -> DStar -> Proc''
findProc = (Maybe.fromJust .) . lookup 

surviveInto :: Set String -> String -> Set String -> Set String -> Set String
surviveInto env name vars dst = if name `member` env then alive <> vars else alive
  where
    alive = delete name dst

survive :: String -> Set String -> Set String -> Set String
survive name vars env = surviveInto env name vars env

surviveOne :: String -> String -> Set String -> Set String
surviveOne name var env = survive name (singleton var) env

constInto :: PtConstLat -> String -> (PtConstLat -> ConstLat) -> PtConstLat -> PtConstLat
constInto env name exp dst = (coerce M.insert) name val' dst
  where
    val  = exp env
    val' = case (coerce M.lookup) name env of
      Just y  -> if val == y then y else NonConst
      Nothing -> val

updateConst :: String -> (PtConstLat -> ConstLat) -> PtConstLat -> PtConstLat
updateConst name exp env = constInto env name exp env
}

{
callStrong :: [String] -> [Set String] -> Set String -> Set String -> Set String
callStrong inputs params r c = appEndo (mconcat $ Endo <$> fs) r
 where
  fs :: [Set String -> Set String]
  fs = surviveInto c <$> inputs <*> params

retStrong :: String -> String -> Set String -> Set String
retStrong name var r = surviveInto r name (singleton var) mempty

callConst :: [String] -> [PtConstLat -> ConstLat] -> PtConstLat -> PtConstLat
callConst inputs params c = appEndo (mconcat $ Endo <$> fs) mempty
  where
    fs :: [PtConstLat -> PtConstLat]
    fs = updateConst <$> inputs <*> params

retConst :: String -> String -> PtConstLat -> PtConstLat -> PtConstLat
retConst retName outName c r = (coerce M.insert) outName (c (coerce M.!) retName) r
}

{-
    lhs.valSpace = {
      insertL @labelCall (const $ (appEndo . mconcat $ (Endo .) . updateConst <$> (procInp @loc.proc) <*> @params) mempty) $
      singleR @labelReturn (\c r -> M.insert @out (constInto r @out (procOut @loc.proc)) c)
    }
-}


sem Program'
  | Program'
    lhs.pretty = unlines ("begin" : indent @procs.pretty ++ indent @stat.pretty ++ ["end"])
    lhs.init = @stat.init
    lhs.final = @stat.final
    lhs.flow = @procs.flow <> @stat.flow
    lhs.strongLive = @procs.strongLive <> @stat.strongLive
    stat.dStar = @dStar
    stat.continueLabel = Nothing
    procs.dStar = @dStar

sem Procs'
  | Nil
    lhs.pretty = []
    lhs.flow = empty
  | Cons
    lhs.pretty = @hd.pretty ++ @tl.pretty
    lhs.flow = @hd.flow <> @tl.flow

sem Proc'
  | Proc'
    lhs.pretty = ["proc " ++ @name ++ "(val " ++ (@inp >>= (++ ", ")) ++ "out " ++ @out ++ ") is" ++ showLabel @labelEntry]
                  ++ indent @stat.pretty
                  ++ ["end" ++ showLabel @labelExit ++ ";"]
    lhs.init = @stat.init
    lhs.final = @stat.final
    lhs.flow = singleton (@labelEntry, @stat.init) <> @stat.flow <> fromList [(label, @labelExit) | label <- toList @stat.final] 
    stat.dStar = @lhs.dStar
    stat.continueLabel = Nothing

sem Stat'
  | Skip'
    lhs.pretty   = ["skip" ++ showLabel @label]
    lhs.isSkip   = True
    lhs.isSingle = True
    lhs.init = @label
    lhs.final = singleton @label
    lhs.flow = empty

  | IfThenElse'
    lhs.pretty   = ["if [" ++ @cond.pretty ++ "]" ++ showLabel @labelc ++ " then" ++ (if @stat1.isSingle then "" else " {")]
                    ++ indent @stat1.pretty
                    ++ (if @stat2.isSkip then (if @stat1.isSingle then [] else ["}"]) else
                            [(if @stat1.isSingle then "" else "} ") ++ "else" ++ (if @stat2.isSingle then "" else " {")]
                        ++ indent @stat2.pretty
                        ++ (if @stat2.isSingle then [] else ["}"])
                      )
    lhs.isSkip   = False
    lhs.isSingle = False
    lhs.init = @labelc
    lhs.final = @stat1.final <> @stat2.final 
    lhs.flow = @stat1.flow <> @stat2.flow <> fromList [(@labelc, @stat1.init), (@labelc, @stat2.init)]
    lhs.strongLive = insertL @labelc (<> @cond.freeVars) $ @stat1.strongLive <> @stat2.strongLive 

  | While'
    lhs.pretty   = ["while [" ++ @cond.pretty ++ "]" ++ showLabel @labelc ++ " do" ++ (if @stat.isSingle then "" else " {")]
                    ++ indent @stat.pretty
                    ++ (if @stat.isSingle then [] else ["}"])
    lhs.isSkip   = False
    lhs.isSingle = False
    lhs.init = @labelc
    lhs.final = singleton @labelc <> @stat.breakLabels
    lhs.flow = @stat.flow <> singleton (@labelc, @stat.init) <> fromList [(label, @labelc) | label <- toList @stat.final ] 
    lhs.continueLabel = Just @labelc
    lhs.breakLabels = empty
    lhs.strongLive = insertL @labelc (<> @cond.freeVars) $ @stat.strongLive

  | Call'
    lhs.pretty   = ["[call " ++ @name ++ "(" ++ @params.pretty ++ @out ++ ")]" ++ showLabel @labelCall ++ "₋" ++ showLabel @labelReturn]
    lhs.isSkip   = False
    lhs.isSingle = True
    lhs.init = @labelCall
    lhs.final = singleton @labelReturn
    loc.proc = { findProc @name @lhs.dStar }
    lhs.interflow = singleton (Inter @labelCall (procEntry @loc.proc) (procExit @loc.proc) @labelReturn)
    lhs.flow = fromList [(@labelCall, (procEntry @loc.proc)), ((procExit @loc.proc), @labelReturn)]

    lhs.strongLive = insertL @labelReturn (retStrong @out $ procOut @loc.proc)    $ singleR @labelCall (callStrong (procInp @loc.proc) @params.freeVars)
    lhs.valSpace   = insertL @labelCall (callConst (procInp @loc.proc) $ @params.expValSpace) $ singleR @labelReturn (retConst @out $ procOut @loc.proc)

  | IAssign'
    lhs.pretty   = ["[" ++ @name ++ " := " ++ @val.pretty ++ "]" ++ showLabel @label]
    lhs.isSkip   = False
    lhs.isSingle = True
    lhs.init = @label
    lhs.final = singleton @label
    lhs.flow = empty
    lhs.strongLive = singleL @label (survive @name @val.freeVars)
    lhs.valSpace = singleL @label (updateConst @name @val.expValSpace)

  | BAssign'
    lhs.pretty   = ["[" ++ @name ++ " := " ++ @val.pretty ++ "]" ++ showLabel @label]
    lhs.isSkip   = False
    lhs.isSingle = True
    lhs.init = @label
    lhs.final = singleton @label
    lhs.flow = empty
    lhs.strongLive = singleL @label (survive @name @val.freeVars)
    lhs.valSpace = singleL @label (updateConst @name @val.expValSpace)

  | Seq'
    lhs.pretty   = addSemicolon @stat1.pretty ++ @stat2.pretty
    lhs.isSkip   = False
    lhs.isSingle = False
    lhs.init = @stat1.init
    lhs.final = @stat2.final
    lhs.flow = @stat1.flow <> @stat2.flow <> fromList [(label, @stat2.init) | label <- toList @stat1.final]

  | Malloc'
    lhs.pretty   = ["malloc(" ++ @name ++ ", " ++ @size.pretty ++ ")" ++ showLabel @label]
    lhs.isSkip   = False
    lhs.isSingle = True
    lhs.init = @label
    lhs.final = singleton @label
    lhs.flow = empty
    lhs.strongLive = singleL @label (survive @name @size.freeVars)
    -- need CL in ConstLat for const prop on lists

  | Free'
    lhs.pretty   = ["free(" ++ @ptr.pretty ++ ")" ++ showLabel @label]
    lhs.isSkip   = False
    lhs.isSingle = True
    lhs.init = @label
    lhs.final = singleton @label
    lhs.flow = empty
    --lhs.strongLive = M.fromList [(@label, survive @ptr @val.freeVars)]

  | RefAssign'
    lhs.pretty   = ["[*" ++ @ptr.pretty ++ " := " ++ @val.pretty ++ "]" ++ showLabel @label]
    lhs.isSkip   = False
    lhs.isSingle = True
    lhs.init = @label
    lhs.final = singleton @label
    lhs.flow = empty
    -- TODO how do we compute strongLive here? (i.e. how do we mark *ptr as live or not)
    
  | Continue'
    lhs.pretty   = ["continue" ++ showLabel @label]
    lhs.isSkip   = False
    lhs.isSingle = True
    lhs.init = @label
    lhs.final = singleton @label
    lhs.flow = singleton (@label, (Maybe.fromJust @lhs.continueLabel))
    
  | Break'
    lhs.pretty   = ["break" ++ showLabel @label]
    lhs.isSkip   = False
    lhs.isSingle = True
    lhs.init = @label
    lhs.final = empty
    lhs.flow = empty
    lhs.breakLabels = singleton @label

{
parensIf :: Bool -> String -> String
parensIf False str = str
parensIf True str = "(" ++ str ++ ")"

cIII :: (Int -> Int -> Int) -> ConstLat -> ConstLat -> ConstLat
cIII f (CI x) (CI y) = CI (x `f` y)
cIII _ NonConst _    = NonConst
cIII _ _ NonConst    = NonConst

cIIB :: (Int -> Int -> Bool) -> ConstLat -> ConstLat -> ConstLat
cIIB f (CI x) (CI y) = CB (x `f` y)
cIIB _ NonConst _    = NonConst
cIIB _ _ NonConst    = NonConst

cBBB :: (Bool -> Bool -> Bool) -> ConstLat -> ConstLat -> ConstLat
cBBB f (CB x) (CB y) = CB (x `f` y)
cBBB _ NonConst _    = NonConst
cBBB _ _ NonConst    = NonConst

cBB :: (Bool -> Bool) -> ConstLat -> ConstLat
cBB f (CB x)   = CB (f x)
cBB _ NonConst = NonConst
}

sem IExpr
  | IConst
    lhs.pretty = show @val
    lhs.precedence = 10
    lhs.expValSpace = \_ -> CI @val
  | Var
    lhs.pretty = @name
    lhs.precedence = 10
    lhs.freeVars = singleton @name
    lhs.expValSpace = (coerce (M.!) @name)
  | Plus
    lhs.pretty = parensIf (@left.precedence < 6) @left.pretty ++ " + " ++ parensIf (@right.precedence <= 6) @right.pretty
    lhs.precedence = 6
    lhs.expValSpace = \env -> cIII (+) (@left.expValSpace env) (@right.expValSpace env)
  | Minus
    lhs.pretty = parensIf (@left.precedence < 6) @left.pretty ++ " - " ++ parensIf (@right.precedence <= 6) @right.pretty
    lhs.precedence = 6
    lhs.expValSpace = \env -> cIII (-) (@left.expValSpace env) (@right.expValSpace env)
  | Times
    lhs.pretty = parensIf (@left.precedence < 7) @left.pretty ++ " * " ++ parensIf (@right.precedence <= 7) @right.pretty
    lhs.precedence = 7
    lhs.expValSpace = \env -> cIII (*) (@left.expValSpace env) (@right.expValSpace env)
  | Divide
    lhs.pretty = parensIf (@left.precedence < 7) @left.pretty ++ " / " ++ parensIf (@right.precedence <= 7) @right.pretty
    lhs.precedence = 7
    lhs.expValSpace = \env -> cIII div (@left.expValSpace env) (@right.expValSpace env)
  | Deref
    lhs.pretty = "*" ++ parensIf (@ptr.precedence < 10) @ptr.pretty
    lhs.precedence = 10
    --lhs.freeVars = singleton @ptr -- TODO what are the freevars here
    -- TODO expValSpace

sem BExpr
  | BConst
    lhs.pretty = show @val
    lhs.precedence = 10
    lhs.expValSpace = \_ -> CB @val
  | BVar
    lhs.pretty = @name
    lhs.precedence = 10
    lhs.freeVars = singleton @name
    lhs.expValSpace = (M.! @name)
  | LessThan
    lhs.pretty = parensIf (@left.precedence <= 4) @left.pretty ++ " < " ++ parensIf (@right.precedence <= 4) @right.pretty
    lhs.precedence = 4
    lhs.expValSpace = \env -> cIIB (<) (@left.expValSpace env) (@right.expValSpace env)
  | GreaterThan
    lhs.pretty = parensIf (@left.precedence <= 4) @left.pretty ++ " > " ++ parensIf (@right.precedence <= 4) @right.pretty
    lhs.precedence = 4
    lhs.expValSpace = \env -> cIIB (>) (@left.expValSpace env) (@right.expValSpace env)
  | LessEqual
    lhs.pretty = parensIf (@left.precedence <= 4) @left.pretty ++ " <= " ++ parensIf (@right.precedence <= 4) @right.pretty
    lhs.precedence = 4
    lhs.expValSpace = \env -> cIIB (<=) (@left.expValSpace env) (@right.expValSpace env)
  | GreaterEqual
    lhs.pretty = parensIf (@left.precedence <= 4) @left.pretty ++ " >= " ++ parensIf (@right.precedence <= 4) @right.pretty
    lhs.precedence = 4
    lhs.expValSpace = \env -> cIIB (>=) (@left.expValSpace env) (@right.expValSpace env)
  | IEqual
    lhs.pretty = parensIf (@left.precedence <= 4) @left.pretty ++ " == " ++ parensIf (@right.precedence <= 4) @right.pretty
    lhs.precedence = 4
    lhs.expValSpace = \env -> cIIB (==) (@left.expValSpace env) (@right.expValSpace env)
  | BEqual
    lhs.pretty = parensIf (@left.precedence <= 4) @left.pretty ++ " == " ++ parensIf (@right.precedence <= 4) @right.pretty
    lhs.precedence = 4
    lhs.expValSpace = \env -> cIIB (==) (@left.expValSpace env) (@right.expValSpace env)
  | And
    lhs.pretty = parensIf (@left.precedence < 3) @left.pretty ++ " && " ++ parensIf (@right.precedence < 3) @right.pretty
    lhs.precedence = 3
    lhs.expValSpace = \env -> cBBB (&&) (@left.expValSpace env) (@right.expValSpace env)
  | Or
    lhs.pretty = parensIf (@left.precedence < 2) @left.pretty ++ " || " ++ parensIf (@right.precedence < 2) @right.pretty
    lhs.precedence = 2
    lhs.expValSpace = \env -> cBBB (||) (@left.expValSpace env) (@right.expValSpace env)
  | Not
    lhs.pretty = "not " ++ parensIf (@val.precedence < 10) @val.pretty
    lhs.precedence = 10
    lhs.expValSpace = \env -> cBB not (@val.expValSpace env)

sem Expr
  | B
    lhs.pretty = @expr.pretty
  | I
    lhs.pretty = @expr.pretty

sem Exprs
  | Nil
    lhs.pretty = ""
  | Cons
    lhs.pretty = @hd.pretty ++ ", " ++ @tl.pretty
